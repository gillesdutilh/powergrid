[{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"introduction-to-the-typical-use-of-powergrid","dir":"Articles","previous_headings":"","what":"Introduction to the typical use of powergrid","title":"powergrid","text":"powergrid package offers number functions facilitate exploring statistical power study. typical use case (also show vignette) want explore relation statistical power, sample size, effect size interest assumed variability data. interrelation parameters defined assumed distributional form data, statistical test aim perform. package dictate ingredients . just allows evaluate function grid parameters visualize interrelation plots fine-tuned analyses power sample size. may, however use different purposes. example close power analysis analysis precision may expect study design. remote application, can think coverage study different confidence intervals. exploration planning recruitment various scenarios.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"functions-covered","dir":"Articles","previous_headings":"Introduction to the typical use of powergrid","what":"Functions covered","title":"powergrid","text":"T vignette covers following functions powergrid PowerGrid evaluating power across grid, without simualtion Example inspecting relation power sample size specific scenario Powerplot Graphical exploration power different scenarios GridPlot Graphical exploration power even scenarios","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"installing-the-current-version-from-github","dir":"Articles","previous_headings":"","what":"Installing the current version from Github","title":"powergrid","text":"install current version github, evaluate following line R code:","code":"devtools::install_github(\"SwissClinicalTrialOrganisation/powergrid\",                          ref = \"v0.1.0\", # the current beta                          build_vignette = TRUE)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"typical-use-case","dir":"Articles","previous_headings":"","what":"Typical use case","title":"powergrid","text":"describe two basic use cases . concern studying relation power, sample size, two parameters. first situation, function calculating power available. second situation, power needs found (re-)sampling.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"power-for-a-t-test-on-a-normal-variable","dir":"Articles","previous_headings":"Typical use case","what":"Power for a t-test on a normal variable","title":"powergrid","text":"Assume aim collect data two-armed RCT plan perform simple t-test. situation, situation concerning power can summarized following ingredients: total sample size effect size interest expected standard deviation study arms objective (planned statistical test) use function PowerGrid evaluate situation sketched . done follows code , first 3 ingredients prepared little list parameters pars. third ingredient, objective, prepared function PowFun. Note simple base R objects. Note , names elements list pars match names function arguments PowFun. set, third part chunk , PowerGrid called sse_pars PowFun arguments pars fun, respectively. result array class power\\_array. can use array, built used neat functions PowerGrid.","code":"sse_pars = list( # a simple list   n = seq(from = 10, to = 60, by = 5), # sample size   delta = seq(from = 0.6, to = 1.6, by = 0.1), # effect size   sd = seq(.5, 1.5, .2) # variability )  PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2,                      delta = delta,                      sd = sd,                      sig.level = 0.05)   return(ptt$power) }  power = PowerGrid(pars = sse_pars, fun = PowFun) summary(power) #>  Object of class: power_array #>  #>  Range of values: [0.08, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, #>   delta 1.6 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"finding-n-for-a-certain-set-of-assumptions","dir":"Articles","previous_headings":"Typical use case","what":"Finding n for a certain set of assumptions","title":"powergrid","text":"First, may want calculate minimal n required achieve, example, power 90%, detecting effect size 0.8, assuming standard deviation sample 0.9. find n, use function Example: printed result Example speak . Note, however, wording “target” function argument printed result may bit vague. ‘“power”?’, may ask. reason , nothing keeps optimizing things functions powergrid. Indeed, instead finding target power, may looking target precision. save output Example, list containing relevant information reusable form:","code":"Example(power, # the object (power_array) I created above         example = list(delta = .8, sd = .9), # at which settings do I want to                                              # calculate n?         target = .9) # what is my target power? #> ================================================ #> To achieve the target of at least 0.9 assuming #> delta = 0.8 #> sd = 0.9, #> the minimal required n = 60 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================ sse_example = Example(power,  example = list(delta = .8, sd = .9), target = .9) str(sse_example) # a list #> List of 7 #>  $ requested_example:List of 2 #>   ..$ delta: num 0.8 #>   ..$ sd   : num 0.9 #>  $ objective        : chr \"achieve target or higher\" #>  $ target           : num 0.9 #>  $ required_name    : chr \"n\" #>  $ required_value   : num 60 #>  $ searched         : chr \"min\" #>  $ method           : chr \"step\" #>  - attr(*, \"class\")= chr \"power_example\""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"exploring-the-uncertainty-about-power","dir":"Articles","previous_headings":"Typical use case","what":"Exploring the uncertainty about power","title":"powergrid","text":"example calcaulted reflect uncertainty study. set sd .9, really know SD expect. may want explore power depends effect size want detect. explore uncertainty power study design study, powergrid offers two plotting functions: PowerPlot GridPlot.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"powerplot","dir":"Articles","previous_headings":"Typical use case > Exploring the uncertainty about power","what":"PowerPlot","title":"powergrid","text":"First, can plot required n different effect sizes chosen SD achieve certain power. , show aim focus assumption standard deviation equals .9. example , want point effect size hope able show, 1. figure shows “isolines” connecting points power .8, .9, .95.  things note: need “slice ” one plain power_array. case, slice sd = .9. slice form figure: delta n. nothing keeps slicing plain delta = .8 show relation power n depends standard deviation. slicing plain n = 50 (maybe ’s considered feasible study project), see power behaves function delta sd. can add additional examples, either increasing length vector argument example, (e.g., example = list(delta = c(1, 1.2))) using higher level plotting function AddExample. latter allows flexibility, like setting different colors line types. many options PowerPlot AddExample may want learn help files.","code":"PowerPlot(   power, # the power_array containing power estimates   slicer = list(sd = .9), # \"cut out\" the relevant slice from power.   example = list(delta = 1) # draw an arrow pointing at the situation at delta = 1   )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"gridplot","dir":"Articles","previous_headings":"Typical use case > Exploring the uncertainty about power","what":"GridPlot","title":"powergrid","text":"figure created PowerPlot can show interplay two variables power. GridPlot often offers insightful picture, particular , example, 2 dimensions pars argument. code shows plot interplay n, delta sd goals achieve 90% power.  Note many options plot. See help file GridPlot info.","code":"GridPlot(power,          target = .9, # you need to choose one target level of power          example = list(delta = 1, sd = .9)) # defined by two parameters now."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"power-evaluation-using-simulation-and-resampling","dir":"Articles","previous_headings":"Typical use case","what":"Power evaluation using simulation and resampling","title":"powergrid","text":"Assume situation , simple solution calculate power: limited pilot data set looks follows: Since really understand distribution (looks pretty right-skewed), plan perform Mann-Whitney U-test. want simply simulate, draw pilot sample mimic variability distributional form. clear idea effect size (somewhere range .5 2). following code approach exploration power:  couple notes: power example calculated simulating TRUE’s FALSE’s significance. automatically summarized mean yield power. may, however, want keep simulated outcomes function. , set summarize = FALSE. choose keep individual iterations, aware plotting functions Example automatically summarize taking mean. can, however, choose different summary_function. range graphical options, including labeling axes lines. PowerPlot, dimension power_array may represented x-axis, y-axis, lines.","code":"pilot_scores = c(2.1, 4.3, 2.3, 5.2, 1.9, 8.3, 7, 2.6, 2.4, 3.2, 2.1, 2.8, 3.4) sse_pars = list(   n = seq(10, 100, 20),   delta = seq(.5, 2, .2)) # only effect size PowFun = function(n, delta, pilot_data){   arm_1 = sample(pilot_data, n, replace = TRUE)   arm_2 = sample(pilot_data, n, replace = TRUE) + delta   significant = wilcox.test(arm_1, arm_2)$p.value < .05   return(significant) # each call of this function gives significant either TRUE                       # or FALSE   } power = PowerGrid(pars = sse_pars,                   fun = PowFun,                   more_args = list(pilot_data = pilot_scores), # pass the pilot                                                                # data on to the                                                                # fun argument                   n_iter = 99) # we need to iterate over simulated experiemtns                                # to get a power. I would take a higher value                                # than 99; this is to keep the example quick. summary(power) #>  Object of class: power_array #> Containing summary over 99 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0.16, 1]  #>  Evaluated at: #>       n 10, 30, 50, 70, 90 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5, 1.7, 1.9 PowerPlot(power)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gilles Dutilh. Author, maintainer.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dutilh G (2025). powergrid: Tools Power Analyis Using Simulations. R package version 0.1.0, https://github.com/SwissClinicalTrialOrganisation/powergrid.","code":"@Manual{,   title = {powergrid: Tools for Power Analyis Using Simulations},   author = {Gilles Dutilh},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/SwissClinicalTrialOrganisation/powergrid}, }"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/index.html","id":"powergrid","dir":"","previous_headings":"","what":"Tools for Power Analyis Using Simulations","title":"Tools for Power Analyis Using Simulations","text":"Powergrid package developed Gilles Dutilh, partly funded Statistical programming grant SCTO. package intended allow users easily evaluate function across grid input parameters. package’ utilities aimed performing analyses power sample size, allowing easy search minimum n (min/max parameter) achieve desired level power (objective). Also, plotting functions included present dependency n power relation parameters. Note package currently (late stage ) development. Development may followed Gilles’ github. encouraged use package released SCTO’s github, currently version v0.1.0. replicability, make sure explicitly refer current release loading package code:","code":"devtools::install_github(\"SwissClinicalTrialOrganisation/powergrid\",                          build_vignette = TRUE) library(powergrid)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example usage","title":"Tools for Power Analyis Using Simulations","text":"Define grid parameters evaluate function across: Define function evaluate parameters across grid. function take parameters input return single value (e.g., power, sample size, etc.). example, can use power.t.test function stats package calculate power t-test: Evaluate function grid node: Display results:  See vignette details use package functions. Please don’t hesitate making issue contributing pull request. may also contact Gilles email.","code":"sse_pars <- list( # a simple list   n = seq(from = 10, to = 60, by = 5), # sample size   sd = seq(from = 0.1, to = 1, by = 0.1) # standard deviation ) PowFun <- function(n, sd){   ptt = power.t.test(n = n/2,                      delta = .6,                      sd = sd,                      sig.level = 0.05)   return(ptt$power) } power <- PowerGrid(pars = sse_pars, fun = PowFun) PowerPlot(power)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an example to an existing PowerPlot or GridPlot — AddExample","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Add example arrow existing power plot created PowerPlot.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"arguments-slicer-and-example","dir":"Reference","previous_headings":"","what":"arguments slicer and example","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"AddExample higher level plotting function, know anything figure draws top . Therefore, need supply arguments x slicer supplied PowerPlot drawing top : slicer define plotted plain, example value x-axis arrow starts. drawing arrows top GridPlot, AddExample guess dimensions defined lines, defined axes. Therefore, need make even explicit slicer, defines line want example . See examples illustration.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"multiple-examples","dir":"Reference","previous_headings":"","what":"multiple examples","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Argument example may contain vector length longer one draw multiple examples. Note examples always one line, one plain. particular drawing top GridPlot, aware draw examples two different lines one call AddExample.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"","code":"AddExample(   x,   slicer = NULL,   example,   target = 0.9,   minimal_target = TRUE,   find_min = TRUE,   method = \"step\",   col = 1,   ... )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"x, slicer, example, target, minimal_target, find_min, method See help PowerPlot. col Color arrow drawn. ... arguments passed two calls function graphics::arrows drawing nicked arrow.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Nothing","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut slice from array (typically of class power_array) — ArraySlicer","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"Cut slice array. resulting slice may single- multidimensional. function intended arrays class \"power_array\", makes sure resulting array class power_array keeps , needed, updates object's attributes. attributes needed various functions powergrid package work well.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"","code":"ArraySlicer(x, slicer = NULL)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"x array, common use cases array class power_array, may array named dimensions. slicer list whose named elements define dimension (list element names), values (list element values) slice taken power_array. Default NULL returns unchanged array.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"array reduced dimensions given slicer. Note , relative standard array, additional attributes passed used functions package powergrid","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"Internally, indexing ([) used, implementation ArraySlicer flexible allowing number dimensions order slicer argument. resulting slice always array, also one dimension left. dimnames kept intact.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"","code":"sse_pars = list(   n = seq(from = 20, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.1, .9, .2),   alpha = c(.05, .025, .1)) # a 4-dimensional grid PowFun <- function(n, delta, sd, alpha){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = alpha)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) ## cut out a 2-dimensional plane: ArraySlicer(power_array,             slicer = list(alpha = .1, sd = .9)) #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta. #>  ## Note that above, the dimension levels are called as numeric values, so the ## following works as well: ArraySlicer(power_array,             slicer = list(alpha = 0.1, sd = 0.9)) #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta. #>  ## They can be called by their actual character values as well: ArraySlicer(power_array,             slicer = list(alpha = '0.1', sd = '0.9')) #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta. #>  ## (compare with dimnames(power_array)) ## the following does not work: if (FALSE) { # \\dontrun{ ArraySlicer(power_array,             slicer = list(alpha = '.1', sd = '.9')) } # } ## ## Cut out multiple levels from one dimension ArraySlicer(power_array,             slicer = list(alpha = .1, sd = c(.9, .7))) #> , , sd = 0.9 #>  #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #>  #> , , sd = 0.7 #>  #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.4570025 0.6935575 0.8685265 0.9584072 0.9904886 0.9984479 #>   25 0.5350629 0.7824609 0.9295853 0.9847885 0.9978551 0.9998053 #>   30 0.6039964 0.8477025 0.9632142 0.9946389 0.9995396 0.9999770 #>   35 0.6643634 0.8946573 0.9811787 0.9981668 0.9999051 0.9999974 #>   40 0.7168148 0.9279025 0.9905394 0.9993888 0.9999811 0.9999997 #>   45 0.7620649 0.9511155 0.9953169 0.9998006 0.9999963 1.0000000 #>   50 0.8008528 0.9671303 0.9977127 0.9999361 0.9999993 1.0000000 #>   55 0.8339099 0.9780638 0.9988960 0.9999799 0.9999999 1.0000000 #>   60 0.8619365 0.9854597 0.9994728 0.9999937 1.0000000 1.0000000 #>  #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta, sd. #>"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":null,"dir":"Reference","previous_headings":"","what":"Find combination of parameters required for achieving a desired power (or other objective). — Example","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"Find combination parameters yielding desired power (target value) object class \"power_array\".","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"","code":"Example(   x,   example = NULL,   target = NULL,   minimal_target = TRUE,   find_min = TRUE,   method = \"step\",   summary_function = mean )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"x Object class power_array example List named elements representing constellation parameter values example found. names list match dimension names x, values exact values available dimensions. See example illustration. target value (typically power) achieved example. minimal_target Logical. Set TRUE aim achieve minimum value (e.g., power must least 90%), FALSE want allow maximum value (e.g., width expected CI may certain value). find_min Logical, indicating whether example found minimizes parameter (typically: minimal required n) achieve target maximizes assumption (e.g., maximal allowed SD). method Character string, indicating location example found, passed internally FindTarget. Either \"step\": walking steps along parameter interest \"lm\": Interpolating assuming linear relation parameter interest (qnorm(x) + qnorm(1 0.05)) ^ 2. method \"lm\" inspired implementation sse package Thomas Fabbro. summary_function x' attribute summarized FALSE, x summarized across sims using function searching example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"Example returns list containing: \"requested_example\": parameter combination power (whatever values represent) searched achieve level target (typically minimal power, e.g., .9), searching along parameter required name (typically n). \"objective\": required_name searched find \"min\" \"max\" x? \"target\": value power (value) ? \"required_name\": parameter searched along find minimum (maximized slot searched = 'max') achieve objective. (typically n) \"required_value\": minimum (maximum searched = \"max\") parameter required_name (typically n) \"searched\": \"min\" \"max\" required_name searched? \"minimal_target\": target minimum (TRUE, typical power) maximum (FALSE, e.g., expected uncertainty level)?","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"typical use case, also default, Example searches minimal n power least equal value given argument target. function , however, designed much generically. explanation may less helpful trying examples, completeness: Argument example slices vector object x, representing values parameter combination given example, thus, along remaining parameter. , Example searches along vector minimal parameter value value vector least equal target. Thus, sliced vector contains values \"power\" along parameter \"effect size\", searches minimal effect size target power achieved. Two complications made allow complete flexibility: description, minimal can changed maximal setting argument find_min FALSE. useful situation one, e.g., searches highest standard deviation still possible find desirable power. description, least can changed setting minimal_target FALSE. allows search, example, minimal sample size expected confidence interval smaller certain desired width. Example searches minimum maximum one parameters (say, minimum n) given one single constellation parameters. However, may want study , say, required n (value) depends value parameters. functions PowerPlot GridPlot offer plotting functionalities graphically illustrate dependencies. want find \"Examples\" function parameter settings work , can use workhorse behind 'Example', PowerPlot Gridplot, FindTarget","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"","code":"## ============================================ ## Typical use case: find lowest n for a certain target power ## ============================================ sse_pars = list(   n = seq(from = 10, to = 60, by = 2),   delta = seq(from = 0.5, to = 1.5, by = 0.1), ## effect size   sd = seq(.1, .9, .2)) ## Standard deviation PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) ##' ex_out = Example(power_array,                  example = list(delta = .7, sd = .7),                  target = .9) ex_out # #> ================================================ #> To achieve the target of at least 0.9 assuming #> delta = 0.7 #> sd = 0.7, #> the minimal required n = 46 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================  ## ============================================ ## Illustration argument `find_min` ## ============================================ ## ## In this example, we search for the *highest sd* for which the power is at ## least .9. ex_out = Example(power_array,                  example = list(n = 40, delta = .7),                  target = .9, find_min = FALSE) ex_out # note how the printed result indicates it searched for a maximal #> ================================================ #> To achieve the target of at least 0.9 assuming #> n = 40 #> delta = 0.7, #> maximal permissible sd = 0.5 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> highest sd in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================                                         # permissible sd.  ## ============================================ ## Illustration argument `minimal_target` ## ============================================ ## ## In the example below, we search for the lowest n where the expected CI-width ## is not larger than .88. PowFun <- function(n, delta, sd){   x1 = rnorm(n = n/2, sd = sd)   x2 = rnorm(n = n/2, mean = delta, sd = sd)   CI_width = diff(t.test(x1, x2)$conf.int) # CI95 is saved } sse_pars = list(   n = seq(from = 10, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2)) ## we iterate, and take the average across iterations to get expected CI-width: n_iter = 20 set.seed(1) power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = n_iter) summary(power_array) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0.51, 4.74]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 ## Now, find lowest n for which the average CI width is *smaller than .88*. ex_out = Example(power_array,                  example = list(delta = .7, sd = .7),                  target = .88,                  find_min = TRUE, # we search the *lowest* n                  minimal_target = FALSE # for a *maximal* mean CI width                  ) ex_out # note how the printed result indicates the target CI is a maximum. #> ================================================ #> To achieve the target of at most 0.88 assuming #> delta = 0.7 #> sd = 0.7, #> the minimal required n = 45 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at most 0.88. #> ================================================  ## ============================================ ## When both `find_min` and `minimal_target` are FALSE ## ============================================ ## ## In this example, we search for the *highest sd* for which the average CI ## width is still *smaller than or equal to .88*. ex_out = Example(power_array,                  example = list(delta = .7, n = 60),                  target = .88,                  find_min = FALSE, # we search the *highest* sd                  minimal_target = FALSE # for a *maximal* mean CI width                  )  ex_out # note how the printed result indicates that the *maximal permissible SD* #> ================================================ #> To achieve the target of at most 0.88 assuming #> delta = 0.7 #> n = 60, #> maximal permissible sd = 0.7 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> highest sd in the searched grid that yields a #> target (typically power) of at most 0.88. #> ================================================        # was found for a CI of *at most .88*."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"Find requirements for target power (or other objective) — FindTarget","title":"Find requirements for target power (or other objective) — FindTarget","text":"FindTarget functions takes input array (typically type power_array), e.g., n effect size, containing crossing power. function searches along one dimension (say n) value (say, power) least () chosen target value (say, power least 90%). done combination levels dimension(s) (say, effect size SD).","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find requirements for target power (or other objective) — FindTarget","text":"","code":"FindTarget(   power_slice,   target = 0.9,   minimal_target = TRUE,   par_to_search = \"n\",   find_min = TRUE,   method = \"step\" )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find requirements for target power (or other objective) — FindTarget","text":"power_slice array, commonly class power_array, possibly result taking slice object class power_array using ArraySlicer power_array []-indexing method. target required value power_slice (e.g., .9, values represent power) minimal_target target minimum (e.g., power) maximum (e.g., size confidence interval) par_to_search parameter searched achieve required target. typical power analysis case, n. find_min TRUE, lowest value par_to_search found yields value meets target. typical n sample size estimation, one searches lowest n achieve certain power. , e.g. variance, one however search maximum target power can still achieved. method required par_to_search achieve target found. Either 'step': walking steps along par_to_search 'lm': Interpolating assuming linear relation par_to_search (qnorm(x) + qnorm(1 -   0.05)) ^ 2. Setting 'lm' inspired implementation sse package Thomas Fabbro.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find requirements for target power (or other objective) — FindTarget","text":"Returns array vector: containing value found par_to_search (say, n) meeting target following criteria (say, lowest n power larger .9), crossing levels dimensions (say, delta, SD).","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find requirements for target power (or other objective) — FindTarget","text":"default, power_slice searched along dimension n (par_to_search), searching lowest value (find_min = TRUE) array contains value least (minimal_target = TRUE) .9 (target), thus finding minimal sample size required achieve power 90%. arguments may seem bit confusing first, allow three additional purposes: First, implementation also allows search value target, setting minimal_target FALSE. may used, example, aim find sample size yielding confidence interval bigger maximum width. Second, implementation allows search along another named dimension power_slice n. Third, implementation allows search certain target achieved maximizing (find_minimum = FALSE) parameter searched dimension. may used, example, aim find maximum standard deviation study's power still acceptable. FindTarget may often implicitly called inside Example, PowerPlot GridPlot.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find requirements for target power (or other objective) — FindTarget","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find requirements for target power (or other objective) — FindTarget","text":"","code":"## ============================================ ## A basic power analysis example: ## ============================================ sse_pars = list(   n = seq(from = 10, to = 60, by = 2),   sig_level = seq(.01, .1, .01),   delta = seq(from = 0.5, to = 1.5, by = 0.2), ## effect size   sd = seq(.1, .9, .2)) ## Standard deviation PowFun <- function(n, sig_level, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = sig_level)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) summary(power_array) #>  Object of class: power_array #>  #>  Range of values: [0.03, 1]  #>  Evaluated at: #>           n 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, #>           n 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, #>           n 58, 60 #>   sig_level 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, #>   sig_level 0.09, 0.1 #>       delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>          sd 0.1, 0.3, 0.5, 0.7, 0.9  ## We can use Example so find the required sample size, but only for one example: Example(power_array,         example = list(delta = .7, sd = .7, sig_level = .05),         target = .9) #> ================================================ #> To achieve the target of at least 0.9 assuming #> delta = 0.7 #> sd = 0.7 #> sig_level = 0.05, #> the minimal required n = 46 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================  ## If we want to see the required sample size for all delta's, we can use ## FindTarget. Get the minimal n needed for achieving a value of 0.9, at sd = ## .3: n_by_delta_sd_03 = FindTarget(power_array[, sig_level = '0.05', , sd = '0.3'],                               par_to_search = 'n',                               target = .9)  n_by_delta_sd_03 #> 0.5 0.7 0.9 1.1 1.3 1.5  #>  18  12  10  10  10  10  ## just as an illustration, a figure (that can be much more aestetically made ## using PowerPlot) plot(as.numeric(names(n_by_delta_sd_03)),      n_by_delta_sd_03, type = 'l')   ## ================================= ## Higher dimensionality ## =================================  ## The function works also for higher dimensionality: n_by_delta_sd = FindTarget(power_array,                            par_to_search = 'n',                            target = .85) ## what is the minimum n to achieve .85 for different values of delta, sd, and sig_level: print(n_by_delta_sd) #> , , sd = 0.1 #>  #>          delta #> sig_level 0.5 0.7 0.9 1.1 1.3 1.5 #>      0.01  10  10  10  10  10  10 #>      0.02  10  10  10  10  10  10 #>      0.03  10  10  10  10  10  10 #>      0.04  10  10  10  10  10  10 #>      0.05  10  10  10  10  10  10 #>      0.06  10  10  10  10  10  10 #>      0.07  10  10  10  10  10  10 #>      0.08  10  10  10  10  10  10 #>      0.09  10  10  10  10  10  10 #>      0.1   10  10  10  10  10  10 #>  #> , , sd = 0.3 #>  #>          delta #> sig_level 0.5 0.7 0.9 1.1 1.3 1.5 #>      0.01  24  14  10  10  10  10 #>      0.02  20  12  10  10  10  10 #>      0.03  18  12  10  10  10  10 #>      0.04  18  10  10  10  10  10 #>      0.05  16  10  10  10  10  10 #>      0.06  16  10  10  10  10  10 #>      0.07  14  10  10  10  10  10 #>      0.08  14  10  10  10  10  10 #>      0.09  14  10  10  10  10  10 #>      0.1   12  10  10  10  10  10 #>  #> , , sd = 0.5 #>  #>          delta #> sig_level 0.5 0.7 0.9 1.1 1.3 1.5 #>      0.01  56  32  20  16  12  10 #>      0.02  50  26  18  14  10  10 #>      0.03  44  24  16  12  10  10 #>      0.04  42  22  16  12  10  10 #>      0.05  38  22  14  10  10  10 #>      0.06  36  20  14  10  10  10 #>      0.07  36  20  12  10  10  10 #>      0.08  34  18  12  10  10  10 #>      0.09  32  18  12  10  10  10 #>      0.1   32  18  12  10  10  10 #>  #> , , sd = 0.7 #>  #>          delta #> sig_level 0.5 0.7 0.9 1.1 1.3 1.5 #>      0.01  NA  56  36  26  20  16 #>      0.02  NA  50  32  22  18  14 #>      0.03  NA  44  28  20  16  12 #>      0.04  NA  42  26  18  14  12 #>      0.05  NA  38  24  18  14  12 #>      0.06  NA  36  24  16  12  10 #>      0.07  NA  36  22  16  12  10 #>      0.08  NA  34  22  16  12  10 #>      0.09  60  32  20  14  12  10 #>      0.1   58  32  20  14  12  10 #>  #> , , sd = 0.9 #>  #>          delta #> sig_level 0.5 0.7 0.9 1.1 1.3 1.5 #>      0.01  NA  NA  56  40  30  24 #>      0.02  NA  NA  50  34  26  20 #>      0.03  NA  NA  44  32  24  18 #>      0.04  NA  NA  42  28  22  18 #>      0.05  NA  NA  38  28  20  16 #>      0.06  NA  60  36  26  20  16 #>      0.07  NA  56  36  24  18  14 #>      0.08  NA  54  34  24  18  14 #>      0.09  NA  52  32  22  16  14 #>      0.1   NA  50  32  22  16  12 #>"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"Plots relation three parameters , typically, power. Two parameters represented x- y-axes, one separate lines.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"","code":"GridPlot(   x,   slicer = NULL,   y_par = NULL,   x_par = NULL,   l_par = NULL,   par_labels = NULL,   example = NULL,   target = 0.8,   method = \"step\",   minimal_target = TRUE,   find_min = TRUE,   col = NULL,   title = NULL,   xlim = NULL,   ylim = NULL,   smooth = FALSE )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"x object class \"power_array\" (powergrid), \"power\" (sse::powEx) \"powCalc\" (sse::powCalc). slicer parameter grid x 3 dimensions, 3-dimensional slice must cut using slicer, list whose elements define values (list element value) parameter (list element name) slice cut. y_par, x_par, l_par parameter varied x- y-axis, lines, respectively. NULL, y_par set first, x_par second, l_par third dimension name x. par_labels Named vector elements names represent parameters plotted, values set desired labels. example list defining combination levels l_par x_par example arrow drawn. List element names indicate parameter, element value indicate values example drawn. target target power (value stored x) matched. method method find required parameter values, see Example FindTarget. minimal_target Logical. target minimally achieved (e.g., power), maximially allowed (e.g., estimation uncertainty). find_min Logical, indicating whether example found minimizes assumption (e.g., minimal required n) achieve target example maximizes assumption (e.g., maximally allowed SD). col vector length l_par defining color(s) lines. title Character string, NULL, replaces default figure title. xlim, ylim See ?graphics::plot. smooth Logical. TRUE, 5th order polynomial fitted though points constituting line smoothing.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"list graphical information use plotting.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"typical use case, y-axis shows minimal sample size required achieve power least target, assuming value parameter x-axis, value parameter represented line. use function , however, limited finding minimum n achieve least certain power. See help Example understand use minimal_target fin_min. Note line may stop corner plotting region, reaching margin. often natural behavior, target level reached anywhere corner parameter range. case n y-axis, may easily solved adding larger sample sizes grid (consider Update), adjusting y-limit include values interest.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"","code":"sse_pars = list(   n = seq(from = 2, to = 100, by = 2),   delta = seq(from = 0.1, to = 1.5, by = 0.05), ## effect size   sd = seq(.1, .9, .1)) ## Standard deviation PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) GridPlot(power_array, target = .8)  ## If that's too many lines, cut out a desired number of slices GridPlot(power_array,          slicer = list(sd = seq(.1, .9, .2)),          target = .8)   ## adjust labels, add example GridPlot(power_array, target = .8,          slicer = list(sd = seq(.1, .9, .2)),          y_par = 'n',          x_par = 'delta',          l_par = 'sd',          par_labels = c('n' = 'Sample Size',                         'delta' = 'Arm Difference',                         'sd' = 'Standard Deviation'),          example = list(sd = .7, delta = .6))  ## Above, GridPlot used the default: The first dimension is what you search ## (often n), the 2nd and 3rd define the grid of parameters at which the search ## is done. Setting this explicitly, with x, y, and l-par, it looks like: GridPlot(power_array, target = .8,          slicer = list(sd = seq(.1, .9, .2)),          y_par = 'n', # search the smallest n where target is achieved          x_par = 'delta',          l_par = 'sd')   ## You may also want to have different parameters on lines and axes: GridPlot(power_array, target = .8,          y_par = 'delta', # search the smallest delta where target is achieved          x_par = 'sd',          l_par = 'n')  ## Too many lines! Take some slices again: GridPlot(power_array, target = .8,          slicer = list(n = c(seq(10, 70, 16))),          y_par = 'delta',          x_par = 'sd',          l_par = 'n', method = 'step')"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform power_array into power_df — PowerDF","title":"Transform power_array into power_df — PowerDF","text":"Transforms object class power_array data.frame, values stored column x, dimensions columns. may find \"tidy\" work . class data.frame becomes `c(\"power_df\", \"data.frame\"), enabling generics data.frame. Note class \"power_df\" currently use included future compatibility.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform power_array into power_df — PowerDF","text":"","code":"PowerDF(x)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform power_array into power_df — PowerDF","text":"x Object class power_array","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform power_array into power_df — PowerDF","text":"object classes c(\"power_df\", \"data.frame\"), attributes x, aside array-native attributes (dimnames, dim), plus data.frame attributes names row_names.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform power_array into power_df — PowerDF","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"PowerGrid apply-like function, allowing evaluate function crossings set parameters. result saved array attributes optimize usage functions package powergrid. particular, performing function iteratively (using parallel computing required) implemented conveniently. typical use evaluating statistical power grid assumed parameters.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"","code":"PowerGrid(   pars,   fun,   more_args = NULL,   n_iter = NA,   summarize = TRUE,   summary_function = mean,   parallel = FALSE,   n_cores = future::availableCores() - 1 )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"pars list element vector values named one arguments fun. fun applied full grid crossing values parameters. fun Function applied combination pars. Arguments may contain element names pars more_args. Output vector, typically length one, outputs generally handled properly functions powergrid. more_args Fixed arguments fun pars. (internally used .mapply supplying argument MoreArgs) n_iter NA, function fun applied n_iter times point grid defined pars. summarize Logical indicating whether iterations (n_iter given) summarized summary_function. summary_function function applied aggregate across simulations. Defaults mean, ignored keep_sims == TRUE .na(n_iter). parallel Logical indicating whether parallel computing applied. TRUE, future::future_replicate used internally. n_cores Passed future_replicate","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"array class \"power_array\", attributes containing informations input arguments, summary status, presence multiple function outputs . object class handled sensibly functions package powergrid, including Example, PowerPlot, GridPlot.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"Function fun evaluated combination argument values listed pars results stored array class power_array, whose dimensions (dimnames()) defined pars. work, element names pars must match argument names fun.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"further-arguments-to-fun","dir":"Reference","previous_headings":"","what":"Further arguments to fun","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"input parameters fun part grid, rather settings, can passed fun argument more_args list names reflecting arguments fun set.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"storing-multiple-outputs-from-fun","dir":"Reference","previous_headings":"","what":"Storing multiple outputs from fun","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"may function fun returns vector length larger one, long single vector. fun returns vector length larger one, power_array additional dimension fun_out, levels named names fun's return vector (given).","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"evaluating-a-function-over-iterations","dir":"Reference","previous_headings":"","what":"Evaluating a function over iterations","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"n_iter NA (default) integer, function fun evaluated n_iter times. add additional dimension 'sim' resulting array class power_array. simulation heavy, may wanna set parallel = TRUE choose n_cores, invoking parallel computing using tfuture::future_replicate. may summarize object individual iterations across iterations using function SummarizeSims. Note summarized non-summarized output PowerGrid class power_array. summary status saved attributes. allows powergrid utilities Example, PowerPlot, GridPlot something sensible also non-summarized objects.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"reproducibility","dir":"Reference","previous_headings":"","what":"Reproducibility","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"current status .Random.seed stored attribute random_seed (list). reproduce call PowerGrid involving randomness, precede new call PowerGrid .Random.seed = attr(<your_power_array>, = 'random.seed')[[1]]. Note Refine() power_array, .Random.seed moment updating appended random.seed attribute. , reconstruct refined power_array, run original call PowerGrid .Random.seed = attr(<your_power_array>, = 'random.seed')[[1]], call Refine .Random.seed = attr(<your_power_array>, = 'random.seed')[[2]], etc.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"","code":"## ======================================================= ## most basic use case, calculating power when ## power function is available: ## =======================================================  ## Define grid of assumptions to study: sse_pars = list(   n = seq(from = 10, to = 60, by = 2),         # sample size   delta = seq(from = 0.5, to = 1.5, by = 0.2), # effect size   sd = seq(.1, .9, .2))                        # standard deviation  ## Define function that calculates power based on these assumptions: PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate at each combination of assumptions:  powarr = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) summary(powarr) #>  Object of class: power_array #>  #>  Range of values: [0.12, 1]  #>  Evaluated at: #>       n 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, #>       n 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, #>       n 58, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.1, 0.3, 0.5, 0.7, 0.9  ## ================================= ## Use powergrid utilities on result ## =================================  ## get required sample size n, when delta is .7, sd = .5, for achieving a ## power of 90%: Example(powarr, example = list(delta = .7, sd = .5), target = .9) #> ================================================ #> To achieve the target of at least 0.9 assuming #> delta = 0.7 #> sd = 0.5, #> the minimal required n = 24 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================  ## Draw a figure illustrating how the required n depends on delta (given an ## sd of .7): PowerPlot(powarr,           slicer = list(sd = .7), # slice out the plane with sd = .7           target = .9, # set target power to 90%, defining the thick line           example = list(delta = .7) # Highlight the example with arrow           )  ## Slice out a sub-array (making sure attributes stay intact for further use in ## powergrid):  only_n20_delta1.1 =   ArraySlicer(powarr, slicer = list(                         n = 20,                         delta = 1.1)) summary(only_n20_delta1.1) #>  Object of class: power_array #>  #>  Range of values: [0.73, 1]  #>  Evaluated at: #>   sd 0.1, 0.3, 0.5, 0.7, 0.9  ## Indexing may also be used, but note that the name of the remaining dimension ## is lost. Therefore, use ArraySlicer when you want to keep working with the ## object in powergrid. only_n20_delta1.1 = powarr[n = 20, delta = 1.1, ] summary(only_n20_delta1.1) #>  Object of class: power_array #>  #>  Range of values: [0.47, 1]   ## ======================================================= ## Simulation over iterations when no power ## function is available ## =======================================================  ## Using the same assumptions as above sse_pars = list(   n = seq(from = 10, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2))  ## Define a function that results in TRUE or FALSE for a successful or ## non-successful (5% significant) simulated trial: PowFun <- function(n, delta, sd){   x1 = rnorm(n = n/2, sd = sd)   x2 = rnorm(n = n/2, mean = delta, sd = sd)   t.test(x1, x2)$p.value < .05 }  ## In call to PowerGrid, setting n_iter prompts PowerGrid to evaluate ## the function iteratively at each combination of assumptions: n_iter = 20 powarr = PowerGrid(pars = sse_pars, fun = PowFun,                         n_iter = n_iter)  ## By default, the iterations are summarized (by their mean), so: dimnames(powarr) #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  summary(powarr) # indicates that iterations were summarized (not stored) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## ================================= ## keeping individual iterations ## =================================  ## To keep individual iterations, set summarize to FALSE:  powarr_no_summary = PowerGrid(pars = sse_pars, fun = PowFun,                                     n_iter = n_iter , summarize = FALSE) dimnames(powarr_no_summary) # additional dimension \"sim\" #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sim #>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" #> [16] \"16\" \"17\" \"18\" \"19\" \"20\" #>  summary(powarr_no_summary) #>  Object of class: power_array #> Containing output of 20 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## To summarize this object containing iterations, use the SummarizeSims ## function. Among other things, this assures that attributes relevant for ## further use in powergrid's functionality are kept intact.  powarr_summarized =   SummarizeSims(powarr_no_summary, summary_function = mean) dimnames(powarr_summarized) #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  summary(powarr_summarized) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `mean` (for function #> definition, see attribute `summary_function`). #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## This summarized `power_array` is no different from a version that was ## directly summarized.  ## Note that Example and Powerplot detect when a `power_array` object is not #summarized, and behave sensibly with a warning: Example(powarr_no_summary, example = list(delta = .7, sd = .5), target = .9) #> Warning: The object 'x' you supplied to Example() #> contains individual iterations. For finding an #> example, these were automatically summarized #> across simulations using the function given in #> argument `summary_function`. #> ================================================ #> To achieve the target of at least 0.9 assuming #> delta = 0.7 #> sd = 0.5, #> the minimal required n = 30 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================  PowerPlot(powarr_no_summary,           slicer = list(sd = .7), # slice out the plane with sd = .7           target = .9, # set target power to 90%, defining the thick line           example = list(delta = .7) # Highlight the example with arrow           ) #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across simulations using the function given in argument `summary_function`.   #======================================================= # Multiple outputs are automatically handled # #=======================================================  ## Parameter assumptions sse_pars = list(   n = seq(from = 10, to = 60, by = 2),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2))  ## A function with two outputs (the power at two significance levels) TwoValuesFun <- function(n, delta, sd){   p5 = power.t.test(n = n, delta = delta, sd = sd, sig.level = .05)$power   p1 = power.t.test(n = n, delta = delta, sd = sd, sig.level = .01)$power   return(c('p5' = p5, 'p1' = p1)) }  powarr_two_returns = PowerGrid(sse_pars, TwoValuesFun)  ## multiple outputs result in an additional dimension: dimnames(powarr_two_returns) #> $n #>  [1] \"10\" \"12\" \"14\" \"16\" \"18\" \"20\" \"22\" \"24\" \"26\" \"28\" \"30\" \"32\" \"34\" \"36\" \"38\" #> [16] \"40\" \"42\" \"44\" \"46\" \"48\" \"50\" \"52\" \"54\" \"56\" \"58\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $fun_out #> [1] \"p5\" \"p1\" #>  summary(powarr_two_returns) #>  Object of class: power_array #>  #>  Range of values:  #>       p5: [0.1, 1] #>       p1: [0.03, 1]  #>  Evaluated at: #>       n 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, #>       n 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, #>       n 58, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## note that you need to tell Example and other powergrid functions, which ## of the outputs you are interested in: Example(powarr_two_returns, example = list(delta = .7, sd = .5, fun_out = 'p1'),         target = .9) #> ================================================ #> To achieve the target of at least 0.9 assuming #> delta = 0.7 #> sd = 0.5 #> fun_out = p1, #> the minimal required n = 18 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target (typically power) of at least 0.9. #> ================================================  PowerPlot(powarr_two_returns,           slicer = list(sd = .7, fun_out = 'p1'), # slice out the plane with the                                                   # output of interest           target = .9, # set target power to 90%, defining the thick line           example = list(delta = .7) # Highlight the example with arrow           )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"Plot (slice ) object class power_array. Main purpose illustrate relation two parameters (e.g., effect size x-axis n y-axis) given target power. example may highlighted drawing arrow combination parameters deemed likely.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"","code":"PowerPlot(   x,   slicer = NULL,   par_to_search = \"n\",   find_min = TRUE,   example = NULL,   method = \"step\",   target = 0.9,   minimal_target = TRUE,   summary_function = mean,   target_levels = c(0.8, 0.9, 0.95),   col = grDevices::grey.colors(1, 0.2, 0.2),   shades_of_grey = TRUE,   shades_legend = FALSE,   title = NULL,   par_labels = NULL,   smooth = NA,   ... )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"x object class power_array (powergrid). slicer parameter grid `x' constructed 2 dimensions, 2-dimensional slice may cut using slicer, list whose elements define values (list element value) parameter (list element name) slice cut . par_to_search variable whose minimum (maximum, find_min == FALSE) searched achieving target_levels. find_min Logical, indicating whether example found minimizes assumption (e.g., minimal required n) achieve target example maximizes assumption (e.g., maximally allowed SD). example NULL, list length one, defining value (list element value) parameter (list element name) example drawn power target. may supply vector longer 1 multiple examples. method Method used finding required par_to_search needed achieve target. Either step: walking steps along par_to_search lm: Interpolating assuming linear relation par_to_search (qnorm(x) + qnorm(1 -   0.05)) ^ 2. setting lm inspired implementation sse package Thomas Fabbro. target power (whatever target ) example, requested, drawn. Also defines power lines drawn thicker line width, among addition power lines defined target_levels. minimal_target Logical. target minimally achieved (e.g., power), maximially allowed (e.g., estimation uncertainty). summary_function x' attribute summarized FALSE, x summarized across sims using function. target_levels levels power (whichever variable contained x) lines drawn. col Color contour lines. effect eventual example arrows. Therefore, use AddExample. shades_of_grey Logical indicating whether greylevels painted addition isolines show power levels. shades_legend Logical indicating whether legend shading added. Note legend drawn separate plotting region, effect setting par(mfrow) current plotting device. title Character string, NULL, replaces default figure title. par_labels Named vector elements named parameters plotted, values desired labels. smooth Numeric, defaults NA, meaning smoothing. Non NA value used argument span smoothing stats::loess, regressing contour values x y-axis. Suggested value .35. Functionality implemented consistency sse package, use discouraged, since regressing contour values flattens contour plot, thereby biasing contour lines. ... arguments passed function image internally. useful zooming xlim ylim.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"Nothing","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"common use case may plotting required n (y-axis) function parameter (e.g., effect size, x-axis) achieving certain level statistical power. default argument settings reflect use case.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"flexible-plotting","dir":"Reference","previous_headings":"","what":"Flexible plotting","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"plotting , however, flexible.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"any-variable-on-the-axes","dir":"Reference","previous_headings":"","what":"Any variable on the axes","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"can flip axes setting different par_to_search (defines y-axis). parameter automatically chosen drawn x-axis.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"maximizing-a-parameter","dir":"Reference","previous_headings":"","what":"Maximizing a parameter","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"One may also search minimum, case sample size, maximum, e.g., highest sd certain power may still achieved. case, par_to_search sd, find_min = FALSE.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"when-smaller-is-better","dir":"Reference","previous_headings":"","what":"When smaller is better","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"standard case power, higher better, search minimal level power. One may however also aim , e.g., maximal width confidence interval. purpose, set minimal_target FALSE. See Example details find_min minimal_target.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"","code":"## ============================================ ## Typical use case: minimal n for power ## ============================================ ## What's the minimal sample size n, given the combination of sd and delta.  ## Set up a grid of n, delta and sd: sse_pars = list(   n = seq(from = 10, to = 60, by = 4),   delta = seq(from = 0.5, to = 1.5, by = 0.1), # effect size   sd = seq(.1, 1.1, .2)) # Standard deviation  ## Define a power function using these parameters: PowFun <- function(n, delta, sd){ # power for a t-test at alpha = .05   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluat PowFun across the grid defined by sse_pars: power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA)  ## explore power graphically in the situation where sd = .7, including an ## example situation where delta is .9: PowerPlot(power_array,           slicer = list(sd = .7),           example = list(delta = .9)           )   ## Some graphical adjustments. Note that example is drawn on top of ## PowerPlot now. PowerPlot(power_array,           slicer = list(sd = .7),           par_labels = c(n = 'Total Sample Size',                          delta = 'Effect Size',                          sd = 'Standard Deviation'),           target_levels = c(.8, .9), # draw fewer power isolines           target = NA # no specific power target (no line thicker)           ) AddExample(power_array,            slicer = list(sd = .7),            example = list(delta = .9),            target = .9,            col = 'Orange', lwd = 3)   ## ============================================ ## Less typical use case: ## minimal delta for power, given sd, as a function of n ## ============================================ ## You can easily change what you search for. For example: At each sample size n, ## what would be the minimal effect size delta there must be for the target ## power to be achieved?  PowerPlot(power_array,           par_to_search = 'delta',           slicer = list(sd = .7))   ## ============================================ ## Less typical use case: ## *maximum sd* for power, given n, as a function of delta ## ============================================ ## You're not limited to study n at all, nor to searching a minimum: When ## your n is given to be 30, what is the largest sd at which we still find ## enough power? (as a function of delta on the x-axis)  PowerPlot(power_array,           par_to_search = 'sd',           find_min = FALSE,           slicer = list(n = 30))  ## Adding an example works the same: If we expect a delta of 1, and the n = ## 30, what is the maximal SD we can have still yielding 90% power?  AddExample(power_array,            find_min = FALSE,            slicer = list(n = 30),            example = list(delta = 1),            target = .9)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintDashes.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw a line of dashes, or something else with a certain width. — PrintDashes","title":"Draw a line of dashes, or something else with a certain width. — PrintDashes","text":"Draw line dashes, something else certain width. used package combination PrintWrap.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintDashes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw a line of dashes, or something else with a certain width. — PrintDashes","text":"","code":"PrintDashes(symbol = \"=\", width = 48, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintDashes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw a line of dashes, or something else with a certain width. — PrintDashes","text":"symbol Symbol repeat width times. width desired width (number symbols) ... arguments passed 'strwrap()'","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintDashes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw a line of dashes, or something else with a certain width. — PrintDashes","text":"character string nchar width","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintDashes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Draw a line of dashes, or something else with a certain width. — PrintDashes","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintWrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap text in printed output. — PrintWrap","title":"Wrap text in printed output. — PrintWrap","text":"Wrap text printed output. function created convenience also width wrapping can set simply changing default . Note give leading white space resulting line. done account fact wrapping deletes whites paces, actually looks good.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintWrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap text in printed output. — PrintWrap","text":"","code":"PrintWrap(x, width = 48, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintWrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap text in printed output. — PrintWrap","text":"x single character string width desired width ... arguments passed 'strwrap()'","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintWrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap text in printed output. — PrintWrap","text":"character string returns placed achieve desired width","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PrintWrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Wrap text in printed output. — PrintWrap","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":null,"dir":"Reference","previous_headings":"","what":"Refine or extend the result of PowerGrid — Refine","title":"Refine or extend the result of PowerGrid — Refine","text":"Add results existing power_array (created PowerGrid another call Refine), adding values pars /larger n_iter.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refine or extend the result of PowerGrid — Refine","text":"","code":"Refine(old, n_iter_add = 1, pars = NULL, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refine or extend the result of PowerGrid — Refine","text":"old object class power_array extend n_iter_add number iterations add old pars new parameter grid evaluate across ... arguments passed PowerGrid internally.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refine or extend the result of PowerGrid — Refine","text":"object class power_array, containing old, extended pars /n_iter_add.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refine or extend the result of PowerGrid — Refine","text":"pars == NULL, update extends old adding iterations n_iter_add existing power_array. pars given, function evaluated old (attribute sim_function) evaluated crossings pars. argument pars different attr(old, = 'pars'), means function evaluated additional crossings parameters. Note certain combinations pars n_iter_add result arrays crossings parameters include iterations others. feature, bug. May result less aesthetic plotting, however. details handling random seed, see PowerGrid.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Refine or extend the result of PowerGrid — Refine","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refine or extend the result of PowerGrid — Refine","text":"","code":"## ============================================ ## very simple example with one parameter ## ============================================ pars = list(x = 1:2) fun = function(x){round(x+runif(1, 0, .2), 3)} # nonsense function set.seed(1) original = PowerGrid(pars = pars,                      fun = fun,                      n_iter = 3,                      summarize = FALSE) refined = Refine(original, n_iter_add = 2, pars = list(x = 2:3)) ## note that refined does not have each parameter sampled in each simulation  ## ============================================ ## a realistic example, simply increasing n_iter ## ============================================ PowFun <- function(n, delta){   x1 = rnorm(n = n/2, sd = 1)   x2 = rnorm(n = n/2, mean = delta, sd = 1)   t.test(x1, x2)$p.value < .05 } sse_pars = list(   n = seq(10, 100, 5),   delta = seq(.5, 1.5, .1)) ## n_iter = 20 set.seed(1) power_array = PowerGrid(pars = sse_pars,                         fun = PowFun,                         n_iter = n_iter,                         summarize = FALSE) summary(power_array) #>  Object of class: power_array #> Containing output of 20 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, #>       n 70, 75, 80, 85, 90, 95, 100 #>   delta 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, #>   delta 1.5 ## add iterations power_array_up = Refine(power_array, n_iter_add = 30) summary(power_array_up) #>  Object of class: power_array #> Containing output of 50 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, #>       n 70, 75, 80, 85, 90, 95, 100 #>   delta 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, #>   delta 1.5  ## ============================================ ## Starting coarsely, then zooming in ## ============================================ sse_pars = list(   n = c(10, 50, 100, 200), # finding n \"ballpark\"   delta = c(.5,  1, 1.5)) # finding delta \"ballpark\" n_iter = 60 power_array = PowerGrid(pars = sse_pars,                         fun = PowFun,                         n_iter = n_iter,                         summarize = FALSE) summary(power_array) #>  Object of class: power_array #> Containing output of 60 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 50, 100, 200 #>   delta 0.5, 1, 1.5 PowerPlot(power_array) #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across simulations using the function given in argument `summary_function`.  ## Based on figure above, let's look at n between 50 and 100, delta around .9 sse_pars = list(   n = seq(50, 100, 5),   delta = seq(.7, 1.1, .05)) set.seed(1) power_array_up = Refine(power_array, n_iter_add = 555, pars = sse_pars) summary(power_array_up) #>  Object of class: power_array #> Containing output of 615 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, #>       n 200 #>   delta 0.5, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1, 1.05, #>   delta 1.1, 1.5 PowerPlot(power_array_up) # that looks funny! It's because the default summary #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across simulations using the function given in argument `summary_function`.                            # mean does not deal with the empty value in the                           # grid. Solution is in illustration below.  ## A visual illustration of this zooming in, in three figures layout(t(1:3)) PowerPlot(power_array, title = 'Course grid to start with') #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across simulations using the function given in argument `summary_function`. PowerPlot(power_array_up, summary_function = function(x)mean(x, na.rm = TRUE),           title = 'Extra samples at finer parameter grid (does not look good)') #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across simulations using the function given in argument `summary_function`. PowerPlot(power_array_up,           slicer = list(n = seq(50, 100, 5),                         delta = seq(.7, 1.1, .05)),           summary_function = function(x)mean(x, na.rm = TRUE),           title = 'Zoomed in') #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across simulations using the function given in argument `summary_function`.  layout(1)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ScaleRange.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale a vector to have a desired range — ScaleRange","title":"Scale a vector to have a desired range — ScaleRange","text":"Linear scaling vector vector required range.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ScaleRange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale a vector to have a desired range — ScaleRange","text":"","code":"ScaleRange(x, a, b)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ScaleRange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale a vector to have a desired range — ScaleRange","text":"x vector desired minimum b desired maximum","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ScaleRange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale a vector to have a desired range — ScaleRange","text":"vector desired minimum maximum","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ScaleRange.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Scale a vector to have a desired range — ScaleRange","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeSims.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of object that has simulations saved. — SummarizeSims","title":"Summary of object that has simulations saved. — SummarizeSims","text":"Summarizes objects class power_array individual simulations saved across simulations.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeSims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of object that has simulations saved. — SummarizeSims","text":"","code":"SummarizeSims(x, summary_function, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeSims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of object that has simulations saved. — SummarizeSims","text":"x Object class power_array summary_function function apply across simulations ... arguments passed 'summary_function'","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeSims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of object that has simulations saved. — SummarizeSims","text":"object class power_array, attributes summarized =   TRUE.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeSims.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary of object that has simulations saved. — SummarizeSims","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":null,"dir":"Reference","previous_headings":"","what":"print — print.power_array","title":"print — print.power_array","text":"Method printing objects class power_array. ##' Prints power_array default array short summary contents.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"print — print.power_array","text":"","code":"# S3 method for class 'power_array' print(x, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"print — print.power_array","text":"x object class power_array ... passed cat","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"print — print.power_array","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Print example — print.power_example","title":"Print example — print.power_example","text":"Print method class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print example — print.power_example","text":"","code":"# S3 method for class 'power_example' print(x, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print example — print.power_example","text":"x object class power_example ... passed cat","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print example — print.power_example","text":"nothing","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print example — print.power_example","text":"Print short informative output object class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print example — print.power_example","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":null,"dir":"Reference","previous_headings":"","what":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"Method indexing [] objects class power_array. method makes sure resulting array class power_array keeps updates object's attributes. attributes needed various functions powergrid package work well. ##' indexing functions normal indexing, note drop FALSE default, resulting array dimensions original array. number levels dimension may reduced, however. ##'","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"","code":"# S3 method for class 'power_array' x[..., drop = TRUE]"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"x object ... index drop drop","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"array class power_grid","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of power_grid object. — summary.power_array","title":"Summary of power_grid object. — summary.power_array","text":"Offers short summary power_array object, summarizing range observed values grid evaluated across. ##' See PowerGrid details","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of power_grid object. — summary.power_array","text":"","code":"# S3 method for class 'power_array' summary(object, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of power_grid object. — summary.power_array","text":"object array class power_grid ... passed cat","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary of power_grid object. — summary.power_array","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Print contents of an example — summary.power_example","title":"Print contents of an example — summary.power_example","text":"Summary method class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print contents of an example — summary.power_example","text":"","code":"# S3 method for class 'power_example' summary(object, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print contents of an example — summary.power_example","text":"object object class power_example ... passed data.frame (thing printed)","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print contents of an example — summary.power_example","text":"nothing","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print contents of an example — summary.power_example","text":"Print longer informative output object class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print contents of an example — summary.power_example","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"powergrid-010","dir":"Changelog","previous_headings":"","what":"powergrid 0.1.0","title":"powergrid 0.1.0","text":"Initial beta release. Use remotes::install_github(\"SwissClinicalTrialOrganisation/powergrid\", ref = \"v0.1.0\") install specific release.","code":""}]

[{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"powergrid","text":"powergrid package made facilitate exploration statistical power study. typical use case (also shown vignette) want explore sample size, effect size interest assumed variability data influence power planned analysis. package dictate ingredients . just allows evaluate function grid parameters visualize interrelation plots fine-tuned analyses power sample size. may, however use powergrid different purposes. example close power analysis analysis precision may expect study design. remote application, can think coverage study different methods calculate confidence intervals. exploration planning recruitment study participants various scenarios.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"functions-covered","dir":"Articles","previous_headings":"Introduction","what":"Functions covered","title":"powergrid","text":"vignette covers following functions powergrid PowerGrid evaluating power across grid, without iterations Example inspecting relation power sample size specific scenario Powerplot Graphical exploration power different scenarios GridPlot Graphical exploration power even scenarios AddExample Add example existing PowerPlot GridPlot FindTarget range parameters, searching along one parameter setting yielding target power (value)","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"installing-the-current-version-from-github","dir":"Articles","previous_headings":"","what":"Installing the current version from Github","title":"powergrid","text":"install current version github, evaluate following line R code:","code":"devtools::install_github(\"SwissClinicalTrialOrganisation/powergrid\",                          build_vignette = TRUE)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"outline","dir":"Articles","previous_headings":"Installing the current version from Github","what":"Outline","title":"powergrid","text":"next section, start showing technical example illustrate essence PowerGrid FindTarget. , third section, show 4 actual use cases exploiting flexibility powergrid.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"technical-example","dir":"Articles","previous_headings":"","what":"Technical example","title":"powergrid","text":"turning real-world example, show example illustrating general working core functions powergrid: PowerGrid FindTarget. Note hardly ever explicitly call FindTarget. PowerGrid essence similar tapply (dplyr::group_by1 + dplyr::summarise). FindTarget essence combination apply + match + min + .min. understand R chunk , understand essence powergrid.","code":"## I aim to create an array with the product of three numbers  ## A function taking the product of three numbers: Prod = function(x, y, z){   x * y * z } ## A grid of numbers I want to calculate the products of. Note that the names of ## the list equal the argument names in Prod() par = list(x = 1:10,            y = 1:3,            z = c(1, 10)) products = PowerGrid(par, Prod) print(products) #> , , z = 1 #>  #>     y #> x      1   2   3 #>   1    1   2   3 #>   2    2   4   6 #>   3    3   6   9 #>   4    4   8  12 #>   5    5  10  15 #>   6    6  12  18 #>   7    7  14  21 #>   8    8  16  24 #>   9    9  18  27 #>   10  10  20  30 #>  #> , , z = 10 #>  #>     y #> x      1   2   3 #>   1   10  20  30 #>   2   20  40  60 #>   3   30  60  90 #>   4   40  80 120 #>   5   50 100 150 #>   6   60 120 180 #>   7   70 140 210 #>   8   80 160 240 #>   9   90 180 270 #>   10 100 200 300 #>  #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  x, y, z.  ## Now, I can ask: for each combination of y and z, what is the lowest x where ## the product is at least 20? FindTarget(products,            par_to_search = 'x',            find_lowest = TRUE,            target_at_least = TRUE,            target_value = 20) #>    z #> y    1 10 #>   1 NA  2 #>   2 10  1 #>   3  7  1 ## Note: when both y and z are 1, there is no x so that the product becomes 20."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"now-forget-about-findtarget","dir":"Articles","previous_headings":"Technical example","what":"Now, forget about FindTarget!","title":"powergrid","text":"typical use cases, use Example(), PowerPlot(), GridPlot() AddExample(), rely FindTarget internally.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"four-use-cases","dir":"Articles","previous_headings":"","what":"Four use cases","title":"powergrid","text":"describe two basic use cases , two slightly fancy ones. first two concern relation power, sample size, two parameters. first situation, function calculating power available. second situation, power needs found (re-)sampling. third example concerns situation objective minimal power, CI-width must certain value. fourth example, search lowest required sample size, highest permissible standard deviation achieve target power.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"ex1","dir":"Articles","previous_headings":"Four use cases","what":"Power and sample size for a t-test","title":"powergrid","text":"Assume aim collect data two-armed RCT plan perform simple t-test. situation, situation concerning power can summarized following ingredients: total sample size effect size interest expected standard deviation study arms objective: achieve significant t-test","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"calculate-and-inspect","dir":"Articles","previous_headings":"Four use cases > Power and sample size for a t-test","what":"Calculate and inspect","title":"powergrid","text":"use function PowerGrid evaluate situation sketched . done follows  code , note names elements list pars match names function arguments PowFun. requirement PowerGrid work.","code":"## A function that returns the power as a function of three input parameters PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2,                      delta = delta,                      sd = sd,                      sig.level = 0.03) # the typical 3% alpha threshold   return(ptt$power) } ## A list of values of input parameters to study pars = list( # a normal list   n = seq(from = 10, to = 60, by = 5), # sample size   delta = seq(from = 0.5, to = 1.7, by = 0.1), # effect size   sd = seq(.5, 1, .1) # variability ) ## Apply PowFun to all crossings of the parameters in pars power = PowerGrid(pars = pars, fun = PowFun) summary(power) #>  Object of class: power_array #>  #>  Range of values: [0.07, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, #>   delta 1.5, 1.6, 1.7 #>      sd 0.5, 0.6, 0.7, 0.8, 0.9, 1 PowerPlot(power,           slicer = list(sd = .7))"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"focus-on-an-example-situation","dir":"Articles","previous_headings":"Four use cases > Power and sample size for a t-test","what":"Focus on an example situation","title":"powergrid","text":"Now, say, want pretty sure (say, power = 90%) detect effect size small 1.1, best guess SD = .7. can calculate example:","code":"Example(power,         example = list(delta = 1.1, sd = .7),         target_value = .9) # power = 90% #> ================================================ #> To achieve the target value of at most 0.9 assuming #> delta = 1.1 #> sd = 0.7, #> the minimal required n = 25 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"draw-a-figure-with-example","dir":"Articles","previous_headings":"Four use cases > Power and sample size for a t-test > Focus on an example situation","what":"Draw a figure with example","title":"powergrid","text":"things note figure code: need “slice ” one plain power_array. case, slice sd = .9. slice form figure: delta n. Note example bit power = 90% line. resolution parameter n: example value delta, arrow points lowest n pars, power least 90%. also slice plain delta = .8 show relation power n depends standard deviation. slice plain n = 50, see power behaves function delta sd. can add additional examples, either increasing length vector argument example, (e.g., example = list(delta = c(1, 1.2))) using higher level plotting function AddExample. latter allows flexibility, like setting different colors line types. many options PowerPlot AddExample may want learn help files.","code":"PowerPlot(power,           slicer = list(sd = .7),           example = list(delta = 1.1),           target_value = .9           )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"why-target-not-power","dir":"Articles","previous_headings":"Four use cases > Power and sample size for a t-test > Focus on an example situation","what":"Why target, not power?","title":"powergrid","text":"wording “target_value” function argument printed result may bit confusing first. ‘“power”?’, may ask. reason , nothing keeps optimizing things functionality powergrid. Indeed, instead finding target power, may looking target precision.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"more-elaborate-exploration-of-power","dir":"Articles","previous_headings":"Four use cases > Power and sample size for a t-test","what":"More elaborate exploration of power","title":"powergrid","text":"PowerPlot already gives insight relation sample size power depends third parameter, effect size. Now, GridPlot offers figure explore one extra parameter.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"gridplot","dir":"Articles","previous_headings":"Four use cases > Power and sample size for a t-test > More elaborate exploration of power","what":"GridPlot","title":"powergrid","text":"figure created PowerPlot can show interplay two variables power. GridPlot often offers insightful picture, particular , example, 2 dimensions pars argument. code shows plot interplay n, delta sd goals achieve 90% power.  Note many options plot. See help file GridPlot info. Importantly, dimension power_array argument x may mapped x- y-axis, different lines.","code":"GridPlot(power,          target_value = .9, # you need to choose one target level of power          example = list(delta = 1, sd = .7)) # defined by two parameters now. #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that #> yielded the required target value, which may result in lines ending abruptly. #> In most common use cases, you may want to increasing the range of n."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"ex2","dir":"Articles","previous_headings":"Four use cases","what":"Power evaluation using simulation and resampling","title":"powergrid","text":"Assume situation , simple solution calculate power: limited pilot data set looks follows: Since really understand distribution (looks pretty right-skewed), plan perform Mann-Whitney U-test. want simply simulate, draw pilot sample mimic variability distributional form. idea effect size (somewhere range .5 2). following code approach exploration power:  couple notes: power example calculated simulating TRUE’s FALSE’s significance. automatically summarized mean yield power. may want keep outcomes individual iterations function. , set summarize = FALSE. situation, resulting array one additional dimension, “iter”. choose keep individual iterations, aware plotting functions Example automatically summarize taking mean. can, however, choose different summary_function. PowerPlot, dimension power_array may represented x-axis, y-axis.","code":"pilot_scores = c(2.1, 4.3, 2.3, 5.2, 1.9, 8.3, 7, 2.6, 2.4, 3.2, 2.1, 2.8, 3.4) sse_pars = list(   n = seq(10, 100, 20),   delta = seq(.5, 2, .2)) # only effect size PowFun = function(n, delta, pilot_data){   arm_1 = sample(pilot_data, n, replace = TRUE)   arm_2 = sample(pilot_data, n, replace = TRUE) + delta   significant = wilcox.test(arm_1, arm_2)$p.value < .03 # the typical 3% alpha threshold   return(significant) # each call of this function gives significant either TRUE                       # or FALSE   } power = PowerGrid(pars = sse_pars,                   fun = PowFun,                   more_args = list(pilot_data = pilot_scores), # pass the pilot                                                                # data on to the                                                                # fun argument                   n_iter = 99) # we need to iterate over simulated experiemtns                                # to get a power. I would take a higher value                                # than 99; this is to keep the example quick. summary(power) #>  Object of class: power_array #> Containing summary over 99 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0.09, 1]  #>  Evaluated at: #>       n 10, 30, 50, 70, 90 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5, 1.7, 1.9 PowerPlot(power)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"ex3","dir":"Articles","previous_headings":"Four use cases","what":"Target a maximum CI95-width","title":"powergrid","text":"powergrid package allows finding power least value. Instead, can target, example, 95% confidence interval certain width. Say, following situation, plan compare two groups t-test want CI wider .7 points outcome scale. Maybe, 7 considered clinically important difference according literature estimates .7 points apart, can’t really conclude anything. can use powergrid functionality find sample size gives us expected CI value:  couple things observe: * set “target_at_least” FALSE, since looking CI .7 * lines figure now connect situations CI-width (power, earlier examples) * changed title accordingly.","code":"CIFun = function(n, delta, sd){   x1 = rnorm(n, mean = 0, sd = sd)   x2 = rnorm(n, mean = delta, sd = sd)    abs(diff(t.test(x1, x2)$conf.int)) # return the CI-width } pars = list( # a normal list   n = seq(from = 10, to = 60, by = 5), # sample size   delta = seq(from = 0.5, to = 1.7, by = 0.1), # effect size   sd = seq(.5, 1, .1) # variability ) set.seed(1) CI_array = PowerGrid(pars, CIFun, n_iter = 20)  summary(CI_array) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0.35, 2.01]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, #>   delta 1.5, 1.6, 1.7 #>      sd 0.5, 0.6, 0.7, 0.8, 0.9, 1 ## This object now contains, for each parameter combination, the CI-width ## averaged over 20 iterations.  Example(CI_array,         example = list(delta = .7, sd = .8),         target_value = .7,         target_at_least = FALSE,         find_lowest = TRUE) #> ================================================ #> To achieve the target value of at most 0.7 assuming #> delta = 0.7 #> sd = 0.8, #> the minimal required n = 45 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at most 0.7. #> ================================================ ## Show results PowerPlot(CI_array, slicer = list(delta = .7),           target_levels = c(.6, .7, .8), # this defines the lines           title = \"CI-width as a funtion of sd and n,\\nassuming delta = .7\",           shades_of_grey = FALSE) # Grey scale is optimized for situation where                                   # the array contains power. AddExample(CI_array,            slicer = list(delta = .7),            example = list(sd = .8),            target_value = .7,            target_at_least = FALSE)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/articles/powergrid.html","id":"ex4","dir":"Articles","previous_headings":"Four use cases","what":"Find the upper bound","title":"powergrid","text":"situation first use case, plan t-test aim power 90%. current situation, however, limited flexibility number participants can recruit. way decreasing variability improving measurements, however. want study small SD must study desirable power. look largest acceptable SD (smallest n) can achieve target value .7. Therefore, set find_lowest = FALSE. see , setting find_lowest = FALSE Example() shows us “maximal permissible” value sd may take order achieve set target. , inspect situation graphic form. Note argument par_to_search set “sd”, putting parameter y-axis.","code":"sse_pars = list(   n = c(30, 40),   delta = seq(from = 0.4, to = 1.2, by = 0.01), ## effect size   sd = seq(.3, .9, .01)) ## Standard deviation PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) Example(power_array,         example = list(n = 30, delta = .8),         find_lowest = FALSE,         target_value = .9) #> ================================================ #> To achieve the target value of at most 0.9 assuming #> n = 30 #> delta = 0.8, #> maximal permissible sd = 0.65 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> highest sd in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================ PowerPlot(power_array,           slicer = list(n = 30),           par_to_search = 'sd',           example = list(delta = .8),           find_lowest = FALSE,           target_value = .9)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gilles Dutilh. Author, maintainer, copyright holder.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dutilh G (2025). powergrid: Power Analysis Across Grid Assumptions. R package version 0.4.0, https://github.com/SwissClinicalTrialOrganisation/powergrid.","code":"@Manual{,   title = {powergrid: Power Analysis Across a Grid of Assumptions},   author = {Gilles Dutilh},   year = {2025},   note = {R package version 0.4.0},   url = {https://github.com/SwissClinicalTrialOrganisation/powergrid}, }"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/index.html","id":"powergrid-","dir":"","previous_headings":"","what":"Power Analysis Across a Grid of Assumptions","title":"Power Analysis Across a Grid of Assumptions","text":"powergrid package intended allow users easily evaluate function across grid input parameters. utilities package aimed performing analyses power sample size, allowing easy search minimum n (min/max parameter) achieve minimal level power (maximum value). Also, plotting functions included present dependency n power relation parameters. Note package currently late stage development. encouraged use package released SCTO’s github, currently version v0.2.0. replicability, make sure explicitly refer current release loading package code: Powergrid package mainly developed Gilles Dutilh, partly funded Statistical programming grant SCTO. Valuable contributions made Richard Allen statistics team DKF basel.","code":"devtools::install_github(\"SwissClinicalTrialOrganisation/powergrid\",                          ref = \"v0.3.0\",                          build_vignette = TRUE) library(powergrid)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example usage","title":"Power Analysis Across a Grid of Assumptions","text":"Define grid parameters evaluate function across: Define function evaluate parameters across grid. function take parameters input return single value (e.g., power, sample size, etc.). example, can use power.t.test function stats package calculate power t-test: Evaluate function grid node: Display results:  See vignette details use package functions. Please don’t hesitate making issue contributing pull request. may also contact Gilles email.","code":"sse_pars <- list( # a simple list   n = seq(from = 10, to = 60, by = 5), # sample size   sd = seq(from = 0.1, to = 1, by = 0.1) # standard deviation ) PowFun <- function(n, sd){   ptt = power.t.test(n = n/2,                      delta = .6,                      sd = sd,                      sig.level = 0.05)   return(ptt$power) } power <- PowerGrid(pars = sse_pars, fun = PowFun) PowerPlot(power)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an example to an existing PowerPlot or GridPlot — AddExample","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Add example arrow(s) existing figure created PowerPlot GridPlot. AddExample higher level plotting function, know anything figure draws top . Therefore, take care figure makes sense, supplying arguments x slicer supplied PowerPlot link{GridPlot} drawing top : slicer define plotted plain, example value x-axis arrow starts. sure sensible result, use argument example inside Powerplot GridPlot.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"","code":"AddExample(   x,   slicer = NULL,   example = NULL,   find_lowest = TRUE,   target_value = NULL,   target_at_least = TRUE,   method = \"step\",   summary_function = mean,   col = grDevices::grey.colors(1, 0.2, 0.2),   example_text = TRUE,   ... )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"x, target_value, target_at_least, find_lowest, method, example_text, summary_function See help PowerPlot. slicer list, internally passed ArraySlicer cut (multidimensional) slice x. can achieve appending \"slicing\" inside argument example. However, assure result AddExample consistent figure draws top (PowerPlot GridPlot), copy arguments x slicer given PowerPlot GridPlot AddTarget. example list, defining value (list element value) parameter(s) (list element name(s)) example drawn power target_value. may supply par vector(s) longer 1 multiple examples. example contains multiple parameters define example, must contain vector length. aware first element example defines parameter x-axis, function fool proof. See argument slicer . x one dimention, example needs defined. col Color arrow text drawn. ... arguments passed two calls function graphics::arrows drawing nicked arrow.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"invisibly NULL","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"arguments-slicer-and-example","dir":"Reference","previous_headings":"","what":"arguments slicer and example","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"slicer takes slice x figure, example defines value parameter, example drawn. arguments' use PowerPlot GridPlot. want make sure result AddExample consistent figure previously created using PowerPlot GridPlot, copy argument slicer function AddExample, define example example. Note however, : slicer = list(= c(1, 2)) example = list(b = c(3, 4)) result : example = list(b = c(3, 4) = c(1, 2))  (defining slicer) Importantly, order example matters , first element defines x-axis.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"multiple-examples","dir":"Reference","previous_headings":"","what":"multiple examples","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Argument example may contain vectors length longer one draw multiple examples.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/AddExample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add an example to an existing PowerPlot or GridPlot — AddExample","text":"","code":"## For more examples, see ?PowerPlot  ## Set up a grid of n, delta and sd: sse_pars = list(   n = seq(from = 10, to = 60, by = 4),   delta = seq(from = 0.5, to = 1.5, by = 0.1), # effect size   sd = seq(.1, 1.1, .2)) # Standard deviation ## Define a power function using these parameters: PowFun <- function(n, delta, sd){ # power for a t-test at alpha = .05   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) } ## Evaluate PowFun across the grid defined by sse_pars: power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA)  ## ====================== ## PowerPlot ## ====================== PowerPlot(power_array,           slicer = list(sd = .7),           ) AddExample(power_array,            slicer = list(sd = .7), # be sure to cut out the same plain as above            example = list(delta = .9),            target_value = .9,            col = 'blue') AddExample(power_array,            slicer = list(sd = .7),            example = list(delta = c(.7, 1)), # multiple examples            target_value = .9,            col = 'yellow') ## Careful, you can move the slicer argument to example: AddExample(power_array,            example = list(delta = 1.2, sd = .7), # delta (x-axis) first            target_value = .9,            col = 'green') ## Careful, because you can put the wrong value on x-axis! AddExample(power_array,            example = list(sd = .7, delta = 1.2), # sd first?!            target_value = .9,            col = 'red')   ## ====================== ## GridPlot ## ====================== GridPlot(power_array, target_value = .9) #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n. AddExample(power_array,            example = list(delta = 1, sd = .7),            target_value = .9            ) ## two examples AddExample(power_array,            example = list(delta = c(.9, 1.2), sd = c(.5, 1.1)),            target_value = .9, col = 3            )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut slice from array (typically of class power_array) — ArraySlicer","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"Cut slice array. resulting slice may single- multidimensional. function intended arrays class \"power_array\", makes sure resulting array class power_array keeps , needed, updates object's attributes. attributes needed various functions powergrid package work well.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"","code":"ArraySlicer(x, slicer = NULL)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"x array, common use cases array class power_array, may array named dimensions. slicer list whose named elements define dimension (list element names), values (list element values) slice taken power_array. Default NULL returns unchanged array.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"array reduced dimensions given slicer. Note , relative standard array, additional attributes passed used functions package powergrid","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"Internally, indexing ([) used, implementation ArraySlicer flexible allowing number dimensions order slicer argument. resulting slice always array, also one dimension left. dimnames kept intact.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/ArraySlicer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut slice from array (typically of class power_array) — ArraySlicer","text":"","code":"sse_pars = list(   n = seq(from = 20, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.1, .9, .2),   alpha = c(.05, .025, .1)) # a 4-dimensional grid PowFun <- function(n, delta, sd, alpha){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = alpha)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) ## cut out a 2-dimensional plane: ArraySlicer(power_array,             slicer = list(alpha = .1, sd = .9)) #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta. #>  ## Note that above, the dimension levels are called as numeric values, so the ## following works as well: ArraySlicer(power_array,             slicer = list(alpha = 0.1, sd = 0.9)) #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta. #>  ## They can be called by their actual character values as well: ArraySlicer(power_array,             slicer = list(alpha = '0.1', sd = '0.9')) #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta. #>  ## (compare with dimnames(power_array)) ## the following does not work: if (FALSE) { # \\dontrun{ ArraySlicer(power_array,             slicer = list(alpha = '.1', sd = '.9')) } # } ## ## Cut out multiple levels from one dimension ArraySlicer(power_array,             slicer = list(alpha = .1, sd = c(.9, .7))) #> , , sd = 0.9 #>  #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.3266194 0.5113619 0.6935575 0.8372357 0.9278669 0.9736115 #>   25 0.3832766 0.5955822 0.7824609 0.9064024 0.9683517 0.9916914 #>   30 0.4363362 0.6675901 0.8477025 0.9473643 0.9865455 0.9974895 #>   35 0.4859190 0.7284933 0.8946573 0.9709510 0.9944270 0.9992664 #>   40 0.5321084 0.7795046 0.9279025 0.9842242 0.9977416 0.9997915 #>   45 0.5749929 0.8218632 0.9511155 0.9915513 0.9991018 0.9999421 #>   50 0.6146775 0.8567685 0.9671303 0.9955305 0.9996486 0.9999843 #>   55 0.6512851 0.8853366 0.9780638 0.9976612 0.9998645 0.9999958 #>   60 0.6849538 0.9085756 0.9854597 0.9987880 0.9999484 0.9999989 #>  #> , , sd = 0.7 #>  #>     delta #> n          0.5       0.7       0.9       1.1       1.3       1.5 #>   20 0.4570025 0.6935575 0.8685265 0.9584072 0.9904886 0.9984479 #>   25 0.5350629 0.7824609 0.9295853 0.9847885 0.9978551 0.9998053 #>   30 0.6039964 0.8477025 0.9632142 0.9946389 0.9995396 0.9999770 #>   35 0.6643634 0.8946573 0.9811787 0.9981668 0.9999051 0.9999974 #>   40 0.7168148 0.9279025 0.9905394 0.9993888 0.9999811 0.9999997 #>   45 0.7620649 0.9511155 0.9953169 0.9998006 0.9999963 1.0000000 #>   50 0.8008528 0.9671303 0.9977127 0.9999361 0.9999993 1.0000000 #>   55 0.8339099 0.9780638 0.9988960 0.9999799 0.9999999 1.0000000 #>   60 0.8619365 0.9854597 0.9994728 0.9999937 1.0000000 1.0000000 #>  #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta, sd. #>"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":null,"dir":"Reference","previous_headings":"","what":"Find combination of parameters required for achieving a desired power (or other objective). — Example","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"Find combination parameters yielding desired power (target value) object class \"power_array\".","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"","code":"Example(   x,   example = NULL,   target_value = NULL,   target_at_least = TRUE,   find_lowest = TRUE,   method = \"step\",   summary_function = mean )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"x Object class power_array example List named elements representing constellation parameter values example found. names list match dimension names x, values exact values available dimensions. See example illustration. target_value value (typically power) achieved example. target_at_least Logical. Set TRUE aim achieve minimum value (e.g., power must least 90%), FALSE want allow maximum value (e.g., width expected CI may certain value). find_lowest Logical, indicating whether example found minimizes parameter (typically: minimal required n) achieve target_value maximizes assumption (e.g., maximal allowed SD). method Character string, indicating location example found, passed internally FindTarget. Either \"step\": walking steps along parameter interest \"lm\": Interpolating assuming linear relation parameter interest (qnorm(x) + qnorm(1 0.05)) ^ 2. method \"lm\" inspired implementation sse package Thomas Fabbro. summary_function x' attribute summarized FALSE, x summarized across iterations using function searching example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"Example returns list containing: \"requested_example\": parameter combination power (whatever values represent) searched achieve level target_value (typically minimal power, e.g., .9), searching along parameter required name (typically n). \"objective\": required_name searched find \"min\" \"max\" x? \"target_value\": value power (value) ? \"required_name\": parameter searched along find minimum (maximized slot searched = 'max') achieve objective. (typically n) \"required_value\": minimum (maximum searched = \"max\") parameter required_name (typically n) \"searched\": \"min\" \"max\" required_name searched? \"target_at_least\": target_value minimum (TRUE, typical power) maximum (FALSE, e.g., expected uncertainty level)?","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"typical use case, also default, Example searches minimal n power least equal value given argument target. function , however, designed much generically. explanation may less helpful trying examples, completeness: Argument example slices vector object x, representing values parameter combination given example, thus, along remaining parameter. , Example searches along vector minimal parameter value value vector least equal target. Thus, sliced vector contains values \"power\" along parameter \"effect size\", searches minimal effect size target power achieved. Two complications made allow complete flexibility: description, minimal can changed maximal setting argument find_lowest FALSE. useful situation one, e.g., searches highest standard deviation still possible find desirable power. description, least can changed setting target_at_least FALSE. allows search, example, minimal sample size expected confidence interval smaller certain desired width. Example searches minimum maximum one parameters (say, minimum n) given one single constellation parameters. However, may want study , say, required n (value) depends value parameters. functions PowerPlot GridPlot offer plotting functionalities graphically illustrate dependencies. want find \"Examples\" function parameter settings work , can use workhorse behind 'Example', PowerPlot Gridplot, FindTarget","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find combination of parameters required for achieving a desired power (or other objective). — Example","text":"","code":"## ============================================ ## Typical use case: find lowest n for a certain target power ## ============================================ sse_pars = list(   n = seq(from = 10, to = 60, by = 2),   delta = seq(from = 0.5, to = 1.5, by = 0.1), ## effect size   sd = seq(.1, .9, .2)) ## Standard deviation PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) ##' ex_out = Example(power_array,                  example = list(delta = .7, sd = .7),                  target_value = .9) ex_out # #> ================================================ #> To achieve the target value of at most 0.9 assuming #> delta = 0.7 #> sd = 0.7, #> the minimal required n = 46 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================  ## ============================================ ## Illustration argument `find_lowest` ## ============================================ ## ## In this example, we search for the *highest sd* for which the power is at ## least .9. ex_out = Example(power_array,                  example = list(n = 40, delta = .7),                  target_value = .9, find_lowest = FALSE) ex_out # note how the printed result indicates it searched for a maximal #> ================================================ #> To achieve the target value of at most 0.9 assuming #> n = 40 #> delta = 0.7, #> maximal permissible sd = 0.5 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> highest sd in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================                                         # permissible sd.  ## ============================================ ## Illustration argument `target_at_least` ## ============================================ ## ## In the example below, we search for the lowest n where the expected CI-width ## is not larger than .88. PowFun <- function(n, delta, sd){   x1 = rnorm(n = n/2, sd = sd)   x2 = rnorm(n = n/2, mean = delta, sd = sd)   CI_width = diff(t.test(x1, x2)$conf.int) # CI95 is saved } sse_pars = list(   n = seq(from = 10, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2)) ## we iterate, and take the average across iterations to get expected CI-width: n_iter = 20 set.seed(1) power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = n_iter) summary(power_array) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0.5, 4.66]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 ## Now, find lowest n for which the average CI width is *smaller than .88*. ex_out = Example(power_array,                  example = list(delta = .7, sd = .7),                  target_value = .88,                  find_lowest = TRUE, # we search the *lowest* n                  target_at_least = FALSE # for a *maximal* mean CI width                  ) ex_out # note how the printed result indicates the target CI is a maximum. #> ================================================ #> To achieve the target value of at most 0.88 assuming #> delta = 0.7 #> sd = 0.7, #> the minimal required n = 40 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at most 0.88. #> ================================================  ## ============================================ ## When both `find_lowest` and `target_at_least` are FALSE ## ============================================ ## ## In this example, we search for the *highest sd* for which the average CI ## width is still *smaller than or equal to .88*. ex_out = Example(power_array,                  example = list(delta = .7, n = 60),                  target_value = .88,                  find_lowest = FALSE, # we search the *highest* sd                  target_at_least = FALSE # for a *maximal* mean CI width                  )  ex_out # note how the printed result indicates that the *maximal permissible SD* #> ================================================ #> To achieve the target value of at most 0.88 assuming #> delta = 0.7 #> n = 60, #> maximal permissible sd = 0.7 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> highest sd in the searched grid that yields a #> target_value (typically power) of at most 0.88. #> ================================================        # was found for a CI of *at most .88*."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"Find requirements for target power (or other objective) — FindTarget","title":"Find requirements for target power (or other objective) — FindTarget","text":"use cases powergrid, need function, rather use convenient functions, notable Example. Example shows smallest sample size still find enough power, largest standard deviation CI95 get large. insight relation parameters resulting power may gained PowerPlot GridPlot. need work , say, required n range assumptions PowerPlot GridPlot, need use FindTarget. FindTarget takes input array (typically class power_array). FindTarget searches () along one chosen dimension value meets set target value (least ). combination remaining dimensions. Concretely, may mean: array contains calculated power combination dimensions n, effect size, SD. function may find, combination effect size SD, lowest n power least, say, .8 achieved. result array effect size SD, containing n's yielding acceptable power.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find requirements for target power (or other objective) — FindTarget","text":"","code":"FindTarget(   x,   par_to_search = \"n\",   find_lowest = TRUE,   target_value = 0.9,   target_at_least = TRUE,   method = \"step\" )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find requirements for target power (or other objective) — FindTarget","text":"x array, commonly class power_array, possibly result taking slice object class power_array using ArraySlicer power_array []-indexing method. par_to_search parameter searched achieve required target value. typical power analysis case, n. find_lowest TRUE, lowest value par_to_search found yields value meets target. typical n sample size estimation, one searches lowest n achieve certain power. , e.g. variance, one however search maximum target power can still achieved. target_value required value x (e.g., .9, values represent power) target_at_least target_value minimum (e.g., power) maximum (e.g., size confidence interval) method required par_to_search achieve target_value found. Either 'step': walking steps along par_to_search 'lm': Interpolating assuming linear relation par_to_search (qnorm(x) + qnorm(1 -   0.05)) ^ 2. Setting 'lm' inspired implementation sse package Thomas Fabbro.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find requirements for target power (or other objective) — FindTarget","text":"Returns array vector: containing value found par_to_search (say, n) meeting target following criteria (say, lowest n power larger .9), crossing levels dimensions (say, delta, SD).","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find requirements for target power (or other objective) — FindTarget","text":"default FindTarget searches along dimension called n (par_to_search), searching lowest value (find_lowest = TRUE) array contains value least (target_at_least = TRUE) .9 (target_value), thus finding minimal sample size required achieve power 90%. arguments may seem bit confusing first, allow three additional purposes: First, implementation also allows search value target_value, setting target_at_least FALSE. may used, example, aim find sample size yielding confidence interval bigger maximum width. Second, implementation allows search along another named dimension x n. Third, implementation allows search certain target value achieved maximizing (find_lowest = FALSE) parameter searched dimension. may used, example, aim find maximum standard deviation study's power still acceptable. FindTarget often called workhorse Example, PowerPlot GridPlot.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find requirements for target power (or other objective) — FindTarget","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/FindTarget.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find requirements for target power (or other objective) — FindTarget","text":"","code":"## ============================================ ## A basic power analysis example: ## ============================================ sse_pars = list(   n = seq(from = 10, to = 60, by = 2),   sig_level = seq(.01, .1, .01),   delta = seq(from = 0.5, to = 1.5, by = 0.2), ## effect size   sd = seq(.1, .9, .2)) ## Standard deviation PowFun <- function(n, sig_level, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = sig_level)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) summary(power_array) # four dimensions #>  Object of class: power_array #>  #>  Range of values: [0.03, 1]  #>  Evaluated at: #>           n 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, #>           n 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, #>           n 58, 60 #>   sig_level 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, #>   sig_level 0.09, 0.1 #>       delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>          sd 0.1, 0.3, 0.5, 0.7, 0.9  ## We can use Example so find the required sample size, but only for one example: Example(power_array,         example = list(delta = .7, sd = .7, sig_level = .05),         target_value = .9) #> ================================================ #> To achieve the target value of at most 0.9 assuming #> delta = 0.7 #> sd = 0.7 #> sig_level = 0.05, #> the minimal required n = 46 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================  ## If we want to see the required sample size for all delta's, we can use ## FindTarget. Get the minimal n needed for achieving a value of 0.9, at sd = ## .3: n_by_delta_sd_03 = FindTarget(power_array[, sig_level = '0.05', , sd = '0.3'],                               par_to_search = 'n',                               target_value = .9)  n_by_delta_sd_03 #> 0.5 0.7 0.9 1.1 1.3 1.5  #>  18  12  10  10  10  10  ## just as an illustration, a figure (that can be much more aestetically made ## using PowerPlot) plot(as.numeric(names(n_by_delta_sd_03)),      n_by_delta_sd_03, type = 'l')   ## ================================= ## Higher dimensionality ## =================================  ## The function works also for higher dimensionality: n_by_delta_sd = FindTarget(power_array,                            par_to_search = 'n',                            target_value = .85) ## what is the minimum n to achieve .85 for different values of delta, sd, ## when  sig_level = 0.05: n_by_delta_sd[5, , ] # note that for some combinations of delta and sd, there is #>      sd #> delta 0.1 0.3 0.5 0.7 0.9 #>   0.5  10  16  38  NA  NA #>   0.7  10  10  22  38  NA #>   0.9  10  10  14  24  38 #>   1.1  10  10  10  18  28 #>   1.3  10  10  10  14  20 #>   1.5  10  10  10  12  16                      # no n yielding the required power at this significance                      # level (NAs)."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"Plots required sample size (parameter) achieve certain power (objective) depends two furhter parameters.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"","code":"GridPlot(   x,   slicer = NULL,   y_par = NULL,   x_par = NULL,   l_par = NULL,   example = NULL,   find_lowest = TRUE,   target_value = 0.9,   target_at_least = TRUE,   method = \"step\",   summary_function = mean,   col = NULL,   example_text = TRUE,   title = NULL,   par_labels = NULL,   xlim = NULL,   ylim = NULL,   smooth = FALSE )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"x object class \"power_array\" (powergrid). slicer parameter grid x 3 dimensions, 3-dimensional slice must cut using slicer, list whose elements define values (list element value) parameter (list element name) slice cut. y_par parameter searched minimum (maximum find_lowest == FALSE) yielding target value; shown y-axis. NULL, y_par set first, x_par second, l_par third dimension name 3-dimensional array x. want another first dimension y_par, need see y_par, x_par, l_par explicitly. x_par, l_par parameter varied x-axis, lines, respectively. none y_par, x_par l_par given, first, second, third dimension x mapped y_par, x_par, l_par, respectively. example list defining combination levels l_par x_par example arrow drawn. List element names indicate parameter, element value indicate values example drawn. find_lowest Logical, indicating whether example found minimizes assumption (e.g., minimal required n) achieve target_value example maximizes assumption (e.g., maximally allowed SD). target_value target power (value stored x) matched. target_at_least Logical. target_value minimally achieved (e.g., power), maximially allowed (e.g., estimation uncertainty). method method find required parameter values, see Example FindTarget. summary_function x object class power_array attribute summarized FALSE (indicating individual iterations stored dimension iter, iterations dimension aggregated summary_fun. Otherwise ignored. col vector length l_par defining color(s) lines. example_text example drawn, required par value, line parameter value printed alongside arrow(s) title Character string, NULL, replaces default figure title. par_labels Named vector elements names represent parameters plotted, values set desired labels. xlim, ylim See ?graphics::plot. smooth Logical. TRUE, 5th order polynomial fitted though points constituting line smoothing.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"list graphical information use plotting.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"typical use case, y-axis shows minimal sample size required achieve power least target_value, assuming value parameter x-axis, value another parameter represented line. use function , however, limited finding minimum n achieve least certain power. See help Example understand use target_at_least fin_min. input argument x (class power_array) contains iterations summarized, summarized summary_function default mean. Note line may stop corner plotting region, reaching margin. often correct behavior, target_value level reached anywhere corner parameter range. case n y-axis, may easily solved adding larger sample sizes grid (consider Update), adjusting y-limit include values interest.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/GridPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot requirements for achieving a target power as a function of assumptions about two parameters — GridPlot","text":"","code":"sse_pars = list(   n = seq(from = 2, to = 100, by = 2),   delta = seq(from = 0.1, to = 1.5, by = 0.05), ## effect size   sd = seq(.1, .9, .1)) ## Standard deviation PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) } power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) GridPlot(power_array, target_value = .8) #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n.  ## If that's too many lines, cut out a desired number of slices GridPlot(power_array,          slicer = list(sd = seq(.1, .9, .2)),          target_value = .8) #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n.   ## adjust labels, add example GridPlot(power_array, target_value = .9,          slicer = list(sd = seq(.1, .9, .2)),          y_par = 'n',          x_par = 'delta',          l_par = 'sd',          par_labels = c('n' = 'Sample Size',                         'delta' = 'Arm Difference',                         'sd' = 'Standard Deviation'),          example = list(sd = .7, delta = .6)) #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n. ## add additional examples useing AddExample. Note that these do not contain ## info about the line they refer to. AddExample(power_array,          target_value = .9,          example = list(delta = c(.5, .8), sd = c(.3, .7)),          col = 3          )    ## Above, GridPlot used the default: The first dimension is what you search ## (often n), the 2nd and 3rd define the grid of parameters at which the #search # is done. Setting this explicitly, with x, y, and l-par, it looks #like: GridPlot(power_array, target_value = .8,          slicer = list(sd = seq(.1, .9, .2)),          y_par = 'n', # search the smallest n where target value is achieved          x_par = 'delta',          l_par = 'sd') #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n.   ## You may also want to have different parameters on lines and axes: GridPlot(power_array, target_value = .8,          y_par = 'delta', # search the smallest delta where target value is achieved          x_par = 'sd',          l_par = 'n') #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n.  ## Too many lines! Take some slices again: GridPlot(power_array, target_value = .9,          slicer = list(n = c(seq(10, 70, 10))),          y_par = 'delta',          x_par = 'sd',          l_par = 'n', method = 'step') #> Warning: At some combinations of `x_par` and `l_par`, no `y_par` was found that yielded the required target value, which may result in lines ending abruptly. In most common use cases, you may want to increasing the range of n."},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform power_array into power_df — PowerDF","title":"Transform power_array into power_df — PowerDF","text":"Transforms object class power_array data.frame, values stored column x, dimensions columns. may find \"tidy\" work . class data.frame becomes `c(\"power_df\", \"data.frame\"), enabling generics data.frame. Note class \"power_df\" currently use included future compatibility.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform power_array into power_df — PowerDF","text":"","code":"PowerDF(x)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform power_array into power_df — PowerDF","text":"x Object class power_array","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform power_array into power_df — PowerDF","text":"object classes c(\"power_df\", \"data.frame\"), attributes x, aside array-native attributes (dimnames, dim), plus data.frame attributes names row_names.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform power_array into power_df — PowerDF","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform power_array into power_df — PowerDF","text":"","code":"## Define grid of assumptions to study: sse_pars = list(   n = seq(from = 10, to = 50, by = 20),         # sample size   delta = seq(from = 0.5, to = 1.5, by = 0.5), # effect size   sd = seq(.1, 1, .3))                        # standard deviation  ## Define function that calculates power based on these assumptions: PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate at each combination of assumptions:  powarr = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) print(PowerDF(powarr)) #>     n delta  sd         x #> 1  10   0.5 0.1 0.9999993 #> 2  30   0.5 0.1 1.0000000 #> 3  50   0.5 0.1 1.0000000 #> 4  10     1 0.1 1.0000000 #> 5  30     1 0.1 1.0000000 #> 6  50     1 0.1 1.0000000 #> 7  10   1.5 0.1 1.0000000 #> 8  30   1.5 0.1 1.0000000 #> 9  50   1.5 0.1 1.0000000 #> 10 10   0.5 0.4 0.4129428 #> 11 30   0.5 0.4 0.9104815 #> 12 50   0.5 0.4 0.9910928 #> 13 10     1 0.4 0.9315752 #> 14 30     1 0.4 0.9999982 #> 15 50     1 0.4 1.0000000 #> 16 10   1.5 0.4 0.9992276 #> 17 30   1.5 0.4 1.0000000 #> 18 50   1.5 0.4 1.0000000 #> 19 10   0.5 0.7 0.1681223 #> 20 30   0.5 0.7 0.4716852 #> 21 50   0.5 0.7 0.6965931 #> 22 10     1 0.7 0.5103278 #> 23 30     1 0.7 0.9652339 #> 24 50     1 0.7 0.9985937 #> 25 10   1.5 0.7 0.8420422 #> 26 30   1.5 0.7 0.9998914 #> 27 50   1.5 0.7 1.0000000 #> 28 10   0.5   1 0.1038399 #> 29 30   0.5   1 0.2619313 #> 30 50   0.5   1 0.4099896 #> 31 10     1   1 0.2859276 #> 32 30     1   1 0.7529210 #> 33 50     1   1 0.9337076 #> 34 10   1.5   1 0.5493642 #> 35 30   1.5   1 0.9774319 #> 36 50   1.5   1 0.9993912"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"PowerGrid apply-like function, allowing evaluate function crossings set parameters. result saved array attributes optimize usage functions package powergrid. particular, performing function iteratively (using parallel computing required) implemented conveniently. typical use evaluating statistical power grid assumed parameters.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"","code":"PowerGrid(   pars,   fun,   more_args = NULL,   n_iter = NA,   summarize = TRUE,   summary_function = mean,   parallel = FALSE,   n_cores = future::availableCores() - 1 )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"pars list element numeric vector values named one arguments fun. fun applied full grid crossing values parameters. aim study numeric parameters, see details. fun function applied combination pars. Arguments may contain element names pars more_args. Output always numeric vector, typically length one. However, want work multiple outpus, can element returned numeric vector. more_args Fixed arguments fun pars. (internally used .mapply supplying argument MoreArgs) n_iter NA, function fun applied n_iter times point grid defined pars. summarize Logical indicating whether iterations (n_iter given) summarized summary_function. summary_function function applied aggregate across iterations. Defaults mean, ignored keep_iters == TRUE .na(n_iter). parallel Logical indicating whether parallel computing applied. TRUE, future::future_replicate used internally. n_cores Passed future_replicate","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"array class \"power_array\", attributes containing informations input arguments, summary status, presence multiple function outputs . object class handled sensibly functions package powergrid, including Example, PowerPlot, GridPlot.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"Function fun evaluated combination argument values listed pars results stored array class power_array, whose dimensions (dimnames()) defined pars. work, element names pars must match argument names fun.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"further-arguments-to-fun","dir":"Reference","previous_headings":"","what":"Further arguments to fun","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"input parameters fun part grid, rather settings, can passed fun argument more_args list names reflecting arguments fun set.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"storing-multiple-outputs-from-fun","dir":"Reference","previous_headings":"","what":"Storing multiple outputs from fun","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"may function fun returns vector length larger one, long single vector. fun returns vector length larger one, power_array additional dimension fun_out, levels named names fun's return vector (given).","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"non-numeric-parameters","dir":"Reference","previous_headings":"","what":"Non-numeric parameters","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"may want study effect non-numeric parameters. option supported argument pars, since essential powergrid functions link{Example}, link{PowerPlot}, link{GridPlot} need direction search. Nonetheless, can study non-numeric parameters function fun returning multiple values, described .","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"evaluating-a-function-over-iterations","dir":"Reference","previous_headings":"","what":"Evaluating a function over iterations","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"n_iter NA (default) integer, function fun evaluated n_iter times. add additional dimension 'iter' resulting array class power_array. simulation heavy, may wanna set parallel = TRUE choose n_cores, invoking parallel computing using tfuture::future_replicate. may summarize object individual iterations across iterations using function SummarizeIterations. Note summarized non-summarized output PowerGrid class power_array. summary status saved attributes. allows powergrid utilities Example, PowerPlot, GridPlot something sensible also non-summarized objects.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"reproducibility","dir":"Reference","previous_headings":"","what":"Reproducibility","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"current status .Random.seed stored attribute random_seed (list). reproduce call PowerGrid involving randomness, precede new call PowerGrid .Random.seed = attr(<your_power_array>, = 'random.seed')[[1]]. Note Refine() power_array, .Random.seed moment updating appended random.seed attribute. , reconstruct refined power_array, run original call PowerGrid .Random.seed = attr(<your_power_array>, = 'random.seed')[[1]], call Refine .Random.seed = attr(<your_power_array>, = 'random.seed')[[2]], etc.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate function (iteratively) at a grid of input arguments — PowerGrid","text":"","code":"## ======================================================= ## most basic use case, calculating power when ## power function is available: ## =======================================================  ## Define grid of assumptions to study: sse_pars = list(   n = seq(from = 10, to = 60, by = 2),         # sample size   delta = seq(from = 0.5, to = 1.5, by = 0.2), # effect size   sd = seq(.1, .9, .2))                        # standard deviation  ## Define function that calculates power based on these assumptions: PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate at each combination of assumptions:  powarr = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) summary(powarr) #>  Object of class: power_array #>  #>  Range of values: [0.12, 1]  #>  Evaluated at: #>       n 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, #>       n 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, #>       n 58, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.1, 0.3, 0.5, 0.7, 0.9  ## ================================= ## Use powergrid utilities on result ## =================================  ## get required sample size n, when delta is .7, sd = .5, for achieving a ## power of 90%: Example(powarr, example = list(delta = .7, sd = .5), target_value = .9) #> ================================================ #> To achieve the target value of at most 0.9 assuming #> delta = 0.7 #> sd = 0.5, #> the minimal required n = 24 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================  ## Draw a figure illustrating how the required n depends on delta (given an ## sd of .7): PowerPlot(powarr,           slicer = list(sd = .7), # slice out the plane with sd = .7           target_value = .9, # set target power to 90%, defining the thick line           example = list(delta = .7) # Highlight the example with arrow           )  ## Slice out a sub-array (making sure attributes stay intact for further use in ## powergrid):  only_n20_delta1.1 =   ArraySlicer(powarr, slicer = list(                         n = 20,                         delta = 1.1)) summary(only_n20_delta1.1) #>  Object of class: power_array #>  #>  Range of values: [0.73, 1]  #>  Evaluated at: #>   sd 0.1, 0.3, 0.5, 0.7, 0.9  ## Indexing may also be used, but note that the name of the remaining dimension ## is lost. Therefore, use ArraySlicer when you want to keep working with the ## object in powergrid. only_n20_delta1.1 = powarr[n = 20, delta = 1.1, ] summary(only_n20_delta1.1) #>  Object of class: power_array #>  #>  Range of values: [0.47, 1]   ## ======================================================= ## Simulation over iterations when no power ## function is available ## =======================================================  ## Using the same assumptions as above sse_pars = list(   n = seq(from = 10, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2))  ## Define a function that results in TRUE or FALSE for a successful or ## non-successful (5% significant) simulated trial: PowFun <- function(n, delta, sd){   x1 = rnorm(n = n/2, sd = sd)   x2 = rnorm(n = n/2, mean = delta, sd = sd)   t.test(x1, x2)$p.value < .05 }  ## In call to PowerGrid, setting n_iter prompts PowerGrid to evaluate ## the function iteratively at each combination of assumptions: n_iter = 20 powarr = PowerGrid(pars = sse_pars, fun = PowFun,                         n_iter = n_iter)  ## By default, the iterations are summarized (by their mean), so: dimnames(powarr) #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  summary(powarr) # indicates that iterations were summarized (not stored) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `summary_function` (for #> function definition, see attribute #> `summary_function`). #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## ================================= ## keeping individual iterations ## =================================  ## To keep individual iterations, set summarize to FALSE:  powarr_no_summary = PowerGrid(pars = sse_pars, fun = PowFun,                                     n_iter = n_iter , summarize = FALSE) dimnames(powarr_no_summary) # additional dimension \"iter\" #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $iter #>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" #> [16] \"16\" \"17\" \"18\" \"19\" \"20\" #>  summary(powarr_no_summary) #>  Object of class: power_array #> Containing output of 20 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## To summarize this object containing iterations, use the SummarizeIterations ## function. Among other things, this assures that attributes relevant for ## further use in powergrid's functionality are kept intact.  powarr_summarized =   SummarizeIterations(powarr_no_summary, summary_function = mean) dimnames(powarr_summarized) #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  summary(powarr_summarized) #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `mean` (for function #> definition, see attribute `summary_function`). #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## This summarized `power_array` is no different from a version that was ## directly summarized.  ## Note that Example and Powerplot detect when a `power_array` object is not #summarized, and behave sensibly with a warning: Example(powarr_no_summary, example = list(delta = .7, sd = .5), target_value = .9) #> Warning: The object 'x' you supplied to Example() contains individual iterations. For finding an example, these were automatically summarized across iterations using the function given in argument `summary_function`. #> ================================================ #> To achieve the target value of at most 0.9 assuming #> delta = 0.7 #> sd = 0.5, #> the minimal required n = 25 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================  PowerPlot(powarr_no_summary,           slicer = list(sd = .7), # slice out the plane with sd = .7           target_value = .9, # set target power to 90%, defining the thick line           example = list(delta = .7) # Highlight the example with arrow           ) #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across iterations using the function given in argument `summary_function`.   #======================================================= # Multiple outputs are automatically handled # #=======================================================  ## Parameter assumptions sse_pars = list(   n = seq(from = 10, to = 60, by = 2),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2))  ## A function with two outputs (the power at two significance levels) TwoValuesFun <- function(n, delta, sd){   p5 = power.t.test(n = n, delta = delta, sd = sd, sig.level = .05)$power   p1 = power.t.test(n = n, delta = delta, sd = sd, sig.level = .01)$power   return(c('p5' = p5, 'p1' = p1)) }  powarr_two_returns = PowerGrid(sse_pars, TwoValuesFun)  ## multiple outputs result in an additional dimension: dimnames(powarr_two_returns) #> $n #>  [1] \"10\" \"12\" \"14\" \"16\" \"18\" \"20\" \"22\" \"24\" \"26\" \"28\" \"30\" \"32\" \"34\" \"36\" \"38\" #> [16] \"40\" \"42\" \"44\" \"46\" \"48\" \"50\" \"52\" \"54\" \"56\" \"58\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $fun_out #> [1] \"p5\" \"p1\" #>  summary(powarr_two_returns) #>  Object of class: power_array #>  #>  Range of values:  #>       p5: [0.1, 1] #>       p1: [0.03, 1]  #>  Evaluated at: #>       n 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, #>       n 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, #>       n 58, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5  ## note that you need to tell Example and other powergrid functions, which ## of the outputs you are interested in: Example(powarr_two_returns, example = list(delta = .7, sd = .5, fun_out = 'p1'),         target_value = .9) #> ================================================ #> To achieve the target value of at most 0.9 assuming #> delta = 0.7 #> sd = 0.5 #> fun_out = p1, #> the minimal required n = 18 #> ------------------------------------------------ #> Description: Method \"step\" was used to find the #> lowest n in the searched grid that yields a #> target_value (typically power) of at least 0.9. #> ================================================  PowerPlot(powarr_two_returns,           slicer = list(sd = .7, fun_out = 'p1'), # slice out the plane with the                                                   # output of interest           target_value = .9, # set target power to 90%, defining the thick line           example = list(delta = .7) # Highlight the example with arrow           )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"Plot (slice ) object class power_array. Main purpose illustrate relation two parameters (e.g., effect size x-axis n y-axis) given target power. example may highlighted drawing arrow combination parameters deemed likely.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"","code":"PowerPlot(   x,   slicer = NULL,   par_to_search = \"n\",   example = NULL,   find_lowest = TRUE,   target_value = 0.9,   target_at_least = TRUE,   method = \"step\",   summary_function = mean,   target_levels = c(0.8, 0.9, 0.95),   col = grDevices::grey.colors(1, 0.2, 0.2),   shades_of_grey = TRUE,   example_text = TRUE,   title = NULL,   par_labels = NULL,   smooth = NA,   ... )"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"x object class power_array (powergrid). slicer parameter grid `x' constructed 2 dimensions, 2-dimensional slice may cut using slicer, list whose elements define values (list element value) parameter (list element name) slice cut . par_to_search variable whose minimum (maximum, find_lowest == FALSE) searched achieving target_levels. example NULL, list length one, defining value (list element value) parameter (list element name) example drawn power target_value. may supply vector longer 1 multiple examples. find_lowest Logical, indicating whether example found minimizes assumption (e.g., minimal required n) achieve target_value example maximizes assumption (e.g., maximally allowed SD). target_value power (whatever target ) example, requested, drawn. Also defines power lines drawn thicker line width, among addition power lines defined target_levels. target_at_least Logical. target value minimally achieved (e.g., power), maximially allowed (e.g., estimation uncertainty). method Method used finding required par_to_search needed achieve target_value. Either step: walking steps along par_to_search lm: Interpolating assuming linear relation par_to_search (qnorm(x) + qnorm(1   - 0.05)) ^ 2. setting lm inspired implementation sse package Thomas Fabbro. summary_function x object class power_array attribute summarized FALSE (individual iterations stored dimension iter, iterations dimension aggregated summary_fun. Otherwise ignored. target_levels levels power (whichever variable contained x) lines drawn. col Color contour lines. effect eventual example arrows. Therefore, use AddExample. shades_of_grey Logical indicating whether greylevels painted addition isolines show power levels. example_text example drawn, required par value printed alongside arrow(s) title Character string, NULL, replaces default figure title. par_labels Named vector elements named parameters plotted, values desired labels. smooth Numeric, defaults NA, meaning smoothing. Non NA value used argument span smoothing stats::loess, regressing contour values x y-axis. Suggested value .35. Functionality implemented consistency sse package, use discouraged, since regressing contour values flattens contour plot, thereby biasing contour lines. ... arguments passed function image internally. useful zooming xlim ylim.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"list containing coordinate arguments x, y, z, passed image() internally.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"common use case may plotting required n (y-axis) function parameter (e.g., effect size, x-axis) achieving certain level statistical power. default argument settings reflect use case.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"flexible-plotting","dir":"Reference","previous_headings":"","what":"Flexible plotting","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"plotting , however, flexible.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"any-variable-on-the-axes","dir":"Reference","previous_headings":"","what":"Any variable on the axes","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"can flip axes setting different par_to_search (defines y-axis). parameter automatically chosen drawn x-axis.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"maximizing-a-parameter","dir":"Reference","previous_headings":"","what":"Maximizing a parameter","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"One may also search minimum, case sample size, maximum, e.g., highest sd certain power may still achieved. case, par_to_search sd, find_lowest = FALSE.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"when-smaller-is-better","dir":"Reference","previous_headings":"","what":"When smaller is better","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"standard case power, higher better, search minimal level power. One may however also aim , e.g., maximal width confidence interval. purpose, set target_at_least FALSE. See Example details find_lowest target_at_least.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/PowerPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the relation between assumed parameters and requirements for achieving a target power (or other objective) — PowerPlot","text":"","code":"## ============================================ ## Typical use case: minimal n for power ## ============================================ ## What's the minimal sample size n, given the combination of sd and delta.  ## Set up a grid of n, delta and sd: sse_pars = list(   n = seq(from = 10, to = 60, by = 4),   delta = seq(from = 0.5, to = 1.5, by = 0.1), # effect size   sd = seq(.1, 1.1, .2)) # Standard deviation  ## Define a power function using these parameters: PowFun <- function(n, delta, sd){ # power for a t-test at alpha = .05   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate PowFun across the grid defined by sse_pars: power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA)  ## explore power graphically in the situation where sd = .7, including an ## example situation where delta is .9: PowerPlot(power_array,           slicer = list(sd = .7),           example = list(delta = c(.7, .9)), # two examples           target_value = .9 # 90% power           )   ## Some graphical adjustments. Note that example is drawn on top of ## PowerPlot now. PowerPlot(power_array,           slicer = list(sd = .7),           par_labels = c(n = 'Total Sample Size',                          delta = 'Effect Size',                          sd = 'Standard Deviation'),           target_levels = c(.8, .9), # draw fewer power isolines           target_value = NA # no specific power target (no line thicker)           ) AddExample(power_array,            slicer = list(sd = .7),            example = list(delta = .9),            target_value = .9,            col = 'Orange', lwd = 3)   ## ============================================ ## Less typical use case: ## minimal delta for power, given sd, as a function of n ## ============================================ ## You can easily change what you search for. For example: At each sample size n, ## what would be the minimal effect size delta there must be for the target ## power to be achieved?  PowerPlot(power_array,           par_to_search = 'delta',           slicer = list(sd = .7))   ## ============================================ ## Less typical use case: ## *maximum sd* for power, given n, as a function of delta ## ============================================ ## You're not limited to study n at all, nor to searching a minimum: When ## your n is given to be 30, what is the largest sd at which we still find ## enough power? (as a function of delta on the x-axis)  PowerPlot(power_array,           par_to_search = 'sd',           find_lowest = FALSE,           slicer = list(n = 30))  ## Adding an example works the same: If we expect a delta of 1, and the n = ## 30, what is the maximal SD we can have still yielding 90% power?  AddExample(power_array,            find_lowest = FALSE,            slicer = list(n = 30),            example = list(delta = 1),            target_value = .9)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":null,"dir":"Reference","previous_headings":"","what":"Refine or extend the result of PowerGrid — Refine","title":"Refine or extend the result of PowerGrid — Refine","text":"Add results existing power_array (created PowerGrid another call Refine), adding values pars /larger n_iter.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refine or extend the result of PowerGrid — Refine","text":"","code":"Refine(old, n_iter_add = 1, pars = NULL, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refine or extend the result of PowerGrid — Refine","text":"old object class power_array extend n_iter_add number iterations add old pars new parameter grid evaluate across ... arguments passed PowerGrid internally.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refine or extend the result of PowerGrid — Refine","text":"object class power_array, containing old, extended pars /n_iter_add.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refine or extend the result of PowerGrid — Refine","text":"pars == NULL, update extends old adding iterations n_iter_add existing power_array. pars given, function evaluated old (attribute sim_function) evaluated crossings pars. argument pars different attr(old, = 'pars'), means function evaluated additional crossings parameters. Note certain combinations pars n_iter_add result arrays crossings parameters include iterations others. feature, bug. May result less aesthetic plotting, however. details handling random seed, see PowerGrid.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Refine or extend the result of PowerGrid — Refine","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/Refine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refine or extend the result of PowerGrid — Refine","text":"","code":"## ============================================ ## very simple example with one parameter ## ============================================ pars = list(x = 1:2) fun = function(x){round(x+runif(1, 0, .2), 3)} # nonsense function set.seed(1) original = PowerGrid(pars = pars,                      fun = fun,                      n_iter = 3,                      summarize = FALSE) refined = Refine(original, n_iter_add = 2, pars = list(x = 2:3)) ## note that refined does not have each parameter sampled in each iteration  ## ============================================ ## a realistic example, simply increasing n_iter ## ============================================ PowFun <- function(n, delta){   x1 = rnorm(n = n/2, sd = 1)   x2 = rnorm(n = n/2, mean = delta, sd = 1)   t.test(x1, x2)$p.value < .05 } sse_pars = list(   n = seq(10, 100, 5),   delta = seq(.5, 1.5, .1)) ## n_iter = 20 set.seed(1) power_array = PowerGrid(pars = sse_pars,                         fun = PowFun,                         n_iter = n_iter,                         summarize = FALSE) summary(power_array) #>  Object of class: power_array #> Containing output of 20 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, #>       n 70, 75, 80, 85, 90, 95, 100 #>   delta 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, #>   delta 1.5 ## add iterations power_array_up = Refine(power_array, n_iter_add = 30) summary(power_array_up) #>  Object of class: power_array #> Containing output of 50 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, #>       n 70, 75, 80, 85, 90, 95, 100 #>   delta 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, #>   delta 1.5  ## ============================================ ## Starting coarsely, then zooming in ## ============================================ sse_pars = list(   n = c(10, 50, 100, 200), # finding n \"ballpark\"   delta = c(.5,  1, 1.5)) # finding delta \"ballpark\" n_iter = 60 power_array = PowerGrid(pars = sse_pars,                         fun = PowFun,                         n_iter = n_iter,                         summarize = FALSE) summary(power_array) #>  Object of class: power_array #> Containing output of 60 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 50, 100, 200 #>   delta 0.5, 1, 1.5 PowerPlot(power_array) #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across iterations using the function given in argument `summary_function`.  ## Based on figure above, let's look at n between 50 and 100, delta around .9 # \\donttest{ sse_pars = list(   n = seq(50, 100, 5),   delta = seq(.7, 1.1, .05)) set.seed(1) power_array_up = Refine(power_array, n_iter_add = 555, pars = sse_pars) summary(power_array_up) #>  Object of class: power_array #> Containing output of 615 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, #>       n 200 #>   delta 0.5, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1, 1.05, #>   delta 1.1, 1.5 PowerPlot(power_array_up) # that looks funny! It's because the default summary #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across iterations using the function given in argument `summary_function`.                            # mean does not deal with the empty value in the                           # grid. Solution is in illustration below.  ## A visual illustration of this zooming in, in three figures layout(t(1:3)) PowerPlot(power_array, title = 'Course grid to start with') #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across iterations using the function given in argument `summary_function`. PowerPlot(power_array_up, summary_function = function(x)mean(x, na.rm = TRUE),           title = 'Extra samples at finer parameter grid (does not look good)') #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across iterations using the function given in argument `summary_function`. PowerPlot(power_array_up,           slicer = list(n = seq(50, 100, 5),                         delta = seq(.7, 1.1, .05)),           summary_function = function(x)mean(x, na.rm = TRUE),           title = 'Zoomed in') #> Warning: The object 'x' you supplied to PowerPlot contains individual iterations. For sensible plotting, these were automatically summarized across iterations using the function given in argument `summary_function`.  layout(1) # }"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeIterations.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of object that has individual iterations saved. — SummarizeIterations","title":"Summary of object that has individual iterations saved. — SummarizeIterations","text":"Summarizes objects class power_array individual iterations saved.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeIterations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of object that has individual iterations saved. — SummarizeIterations","text":"","code":"SummarizeIterations(x, summary_function, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeIterations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of object that has individual iterations saved. — SummarizeIterations","text":"x Object class power_array summary_function function apply across iterations ... arguments passed 'summary_function'","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeIterations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of object that has individual iterations saved. — SummarizeIterations","text":"object class power_array, attributes summarized =   TRUE.","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeIterations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary of object that has individual iterations saved. — SummarizeIterations","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/SummarizeIterations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of object that has individual iterations saved. — SummarizeIterations","text":"","code":"## iterative sse example sse_pars = list(   n = seq(from = 10, to = 60, by = 5),   delta = seq(from = 0.5, to = 1.5, by = 0.2),   sd = seq(.5, 1.5, .2))  ## Define a function that results in TRUE or FALSE for a successful or ## non-successful (5% significant) simulated trial: PowFun <- function(n, delta, sd){   x1 = rnorm(n = n/2, sd = sd)   x2 = rnorm(n = n/2, mean = delta, sd = sd)   t.test(x1, x2)$p.value < .05 }  n_iter = 20 powarr = PowerGrid(pars = sse_pars, fun = PowFun,                         n_iter = n_iter, summarize = FALSE)  dimnames(powarr) #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $iter #>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" #> [16] \"16\" \"17\" \"18\" \"19\" \"20\" #>  summary(powarr) # indicates that iterations were not #>  Object of class: power_array #> Containing output of 20 individual iterations. #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 ## now summarize powarr_summarized = SummarizeIterations(powarr, summary_function = mean) dimnames(powarr_summarized) #> $n #>  [1] \"10\" \"15\" \"20\" \"25\" \"30\" \"35\" \"40\" \"45\" \"50\" \"55\" \"60\" #>  #> $delta #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  #> $sd #> [1] \"0.5\" \"0.7\" \"0.9\" \"1.1\" \"1.3\" \"1.5\" #>  summary(powarr_summarized) # indicates that iterations are now summarized #>  Object of class: power_array #> Containing summary over 20 iterations, #> summarized by function `mean` (for function #> definition, see attribute `summary_function`). #>  Range of values: [0, 1]  #>  Evaluated at: #>       n 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60 #>   delta 0.5, 0.7, 0.9, 1.1, 1.3, 1.5 #>      sd 0.5, 0.7, 0.9, 1.1, 1.3, 1.5"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":null,"dir":"Reference","previous_headings":"","what":"print — print.power_array","title":"print — print.power_array","text":"Method printing objects class power_array. ##' Prints power_array default array short summary contents.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"print — print.power_array","text":"","code":"# S3 method for class 'power_array' print(x, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"print — print.power_array","text":"x object class power_array ... passed cat","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"print — print.power_array","text":"Nothing","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"print — print.power_array","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_array.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"print — print.power_array","text":"","code":"## Define grid of assumptions to study: sse_pars = list(   n = seq(from = 10, to = 50, by = 20),         # sample size   delta = seq(from = 0.5, to = 1.5, by = 0.5), # effect size   sd = seq(.1, 1, .3))                        # standard deviation  ## Define function that calculates power based on these assumptions: PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate at each combination of assumptions:  powarr = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) print(powarr) #> , , sd = 0.1 #>  #>     delta #> n          0.5         1       1.5 #>   10 0.9999993 1.0000000 1.0000000 #>   30 1.0000000 1.0000000 1.0000000 #>   50 1.0000000 1.0000000 1.0000000 #>  #> , , sd = 0.4 #>  #>     delta #> n          0.5         1       1.5 #>   10 0.4129428 0.9315752 0.9992276 #>   30 0.9104815 0.9999982 1.0000000 #>   50 0.9910928 1.0000000 1.0000000 #>  #> , , sd = 0.7 #>  #>     delta #> n          0.5         1       1.5 #>   10 0.1681223 0.5103278 0.8420422 #>   30 0.4716852 0.9652339 0.9998914 #>   50 0.6965931 0.9985937 1.0000000 #>  #> , , sd = 1 #>  #>     delta #> n          0.5         1       1.5 #>   10 0.1038399 0.2859276 0.5493642 #>   30 0.2619313 0.7529210 0.9774319 #>   50 0.4099896 0.9337076 0.9993912 #>  #> Array of class `power_array` created using #> PowerGrid. #>  Resulting dimensions: #>  n, delta, sd. #>"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Print example — print.power_example","title":"Print example — print.power_example","text":"Print method class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print example — print.power_example","text":"","code":"# S3 method for class 'power_example' print(x, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print example — print.power_example","text":"x object class power_example ... passed cat","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print example — print.power_example","text":"nothing","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print example — print.power_example","text":"Print short informative output object class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/print.power_example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print example — print.power_example","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":null,"dir":"Reference","previous_headings":"","what":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"Method indexing [] objects class power_array. method makes sure resulting array class power_array keeps updates object's attributes. attributes needed various functions powergrid package work well. ##' indexing functions normal indexing, note drop FALSE default, resulting array dimensions original array. number levels dimension may reduced, however. ##'","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"","code":"# S3 method for class 'power_array' x[..., drop = TRUE]"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"x object ... index drop drop","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"array class power_grid","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/sub-.power_array.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"indexing with [ ] for class power_array [ ]: R:%20 — [.power_array","text":"","code":"## Define grid of assumptions to study: sse_pars = list(   n = seq(from = 10, to = 50, by = 20),         # sample size   delta = seq(from = 0.5, to = 1.5, by = 0.5), # effect size   sd = seq(.1, 1, .3))                        # standard deviation  ## Define function that calculates power based on these assumptions: PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate at each combination of assumptions:  powarr = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) powarr[2, 1, ] # gives the same as #> [1] 1.0000000 0.9104815 0.4716852 0.2619313 #> Array of class `power_array` created using #> PowerGrid. #>   One resulting dimension (dimension's name was dropped by indexing). #>  powarr['30', '0.5', ] #> [1] 1.0000000 0.9104815 0.4716852 0.2619313 #> Array of class `power_array` created using #> PowerGrid. #>   One resulting dimension (dimension's name was dropped by indexing). #>"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of power_grid object. — summary.power_array","title":"Summary of power_grid object. — summary.power_array","text":"Offers short summary power_array object, summarizing range observed values grid evaluated across. ##' See PowerGrid details","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of power_grid object. — summary.power_array","text":"","code":"# S3 method for class 'power_array' summary(object, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of power_grid object. — summary.power_array","text":"object array class power_grid ... passed cat","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of power_grid object. — summary.power_array","text":"nothing","code":""},{"path":[]},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary of power_grid object. — summary.power_array","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_array.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of power_grid object. — summary.power_array","text":"","code":"## Define grid of assumptions to study: sse_pars = list(   n = seq(from = 10, to = 50, by = 20),         # sample size   delta = seq(from = 0.5, to = 1.5, by = 0.5), # effect size   sd = seq(.1, 1, .3))                        # standard deviation  ## Define function that calculates power based on these assumptions: PowFun <- function(n, delta, sd){   ptt = power.t.test(n = n/2, delta = delta, sd = sd,                      sig.level = 0.05)   return(ptt$power) }  ## Evaluate at each combination of assumptions:  powarr = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA) summary(powarr) #>  Object of class: power_array #>  #>  Range of values: [0.1, 1]  #>  Evaluated at: #>       n 10, 30, 50 #>   delta 0.5, 1, 1.5 #>      sd 0.1, 0.4, 0.7, 1"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Print contents of an example — summary.power_example","title":"Print contents of an example — summary.power_example","text":"Summary method class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print contents of an example — summary.power_example","text":"","code":"# S3 method for class 'power_example' summary(object, ...)"},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print contents of an example — summary.power_example","text":"object object class power_example ... passed data.frame (thing printed)","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print contents of an example — summary.power_example","text":"nothing","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print contents of an example — summary.power_example","text":"Print longer informative output object class power_example.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/reference/summary.power_example.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print contents of an example — summary.power_example","text":"Gilles Dutilh","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"powergrid-040","dir":"Changelog","previous_headings":"","what":"powergrid 0.4.0","title":"powergrid 0.4.0","text":"Omitted settings par(), including graphics::layout() (PowerPlot GridPlot) Argument shades_legend removed argument PowerPlot. related function add legend grey scale omitted . legend difficult position without setting par. Also, use legend limited, since eye notoriously bad seeing equality difference shades share border. (PowerPlot) Omitted (conditional) set.seed() PowerGrid. seed set cases happens .Random.seed yet. Slightly tweaky circumvented always drawing one uniform number anything. # powergrid 0.3.0 performed checks listed issue #55 Release powergrid 0.3.0","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"powergrid-021","dir":"Changelog","previous_headings":"","what":"powergrid 0.2.1","title":"powergrid 0.2.1","text":"typos","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"powergrid-020","dir":"Changelog","previous_headings":"","what":"powergrid 0.2.0","title":"powergrid 0.2.0","text":"large, still minor update. arguments renamed one function new name. Vignette improved greatly, documentation updated extended. Cross-referencing Documentation improved. Warnings documentation consistent now. Beta release. Use remotes::install_github(\"SwissClinicalTrialOrganisation/powergrid\", ref =   \"v0.2.0\") install . package soon sumbitted CRAN. changes user side planned.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"powergrid 0.2.0","text":"SummarizeIterations() replaces older SummarizeSims. Iterations may, must simulations. Language consistency adjusted throughout package. documentation, well attributes power_array objects, “sim” , relevant, replaced “iter”. find_lowest replaces find_min target_at_least replaces minimal_target target_value replaces target Compatibility sse package omitted. see offline updated. Keeping working eventual sse output error-prone little use.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"improvements-user-level-0-2-0","dir":"Changelog","previous_headings":"","what":"Improvements user level","title":"powergrid 0.2.0","text":"help files improved Vignette extended improved Tests included! (thanks Richard!) Input handling functions respective errors warnings improved. PowerPlot Example naturally deal one-dimensional power_array object. PowerPlot special figure represent one-dimensional situation.","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"improvements-under-the-hood-0-2-0","dir":"Changelog","previous_headings":"","what":"Improvements under the hood","title":"powergrid 0.2.0","text":"plotting examples inside PowerPlot() now handled AddExample. Summarizing across dimenstions inside power_grid now performed SummarizeIterations() (Thanks Richard!)","code":""},{"path":"https://swissclinicaltrialorganisation.github.io/powergrid/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"bug fixes","title":"powergrid 0.2.0","text":"multitude bugs fixed","code":""}]
